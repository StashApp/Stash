// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"bytes"
	"context"
	"errors"
	"io"
	"strconv"
	"sync"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Gallery() GalleryResolver
	Mutation() MutationResolver
	Performer() PerformerResolver
	Query() QueryResolver
	Scene() SceneResolver
	SceneMarker() SceneMarkerResolver
	Studio() StudioResolver
	Subscription() SubscriptionResolver
	Tag() TagResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	ConfigGeneralResult struct {
		Stashes       func(childComplexity int) int
		DatabasePath  func(childComplexity int) int
		GeneratedPath func(childComplexity int) int
	}

	ConfigResult struct {
		General func(childComplexity int) int
	}

	FindGalleriesResultType struct {
		Count     func(childComplexity int) int
		Galleries func(childComplexity int) int
	}

	FindPerformersResultType struct {
		Count      func(childComplexity int) int
		Performers func(childComplexity int) int
	}

	FindSceneMarkersResultType struct {
		Count        func(childComplexity int) int
		SceneMarkers func(childComplexity int) int
	}

	FindScenesResultType struct {
		Count  func(childComplexity int) int
		Scenes func(childComplexity int) int
	}

	FindStudiosResultType struct {
		Count   func(childComplexity int) int
		Studios func(childComplexity int) int
	}

	Gallery struct {
		Id       func(childComplexity int) int
		Checksum func(childComplexity int) int
		Path     func(childComplexity int) int
		Title    func(childComplexity int) int
		Files    func(childComplexity int) int
	}

	GalleryFilesType struct {
		Index func(childComplexity int) int
		Name  func(childComplexity int) int
		Path  func(childComplexity int) int
	}

	MarkerStringsResultType struct {
		Count func(childComplexity int) int
		Id    func(childComplexity int) int
		Title func(childComplexity int) int
	}

	Mutation struct {
		SceneUpdate        func(childComplexity int, input SceneUpdateInput) int
		SceneMarkerCreate  func(childComplexity int, input SceneMarkerCreateInput) int
		SceneMarkerUpdate  func(childComplexity int, input SceneMarkerUpdateInput) int
		SceneMarkerDestroy func(childComplexity int, id string) int
		PerformerCreate    func(childComplexity int, input PerformerCreateInput) int
		PerformerUpdate    func(childComplexity int, input PerformerUpdateInput) int
		StudioCreate       func(childComplexity int, input StudioCreateInput) int
		StudioUpdate       func(childComplexity int, input StudioUpdateInput) int
		TagCreate          func(childComplexity int, input TagCreateInput) int
		TagUpdate          func(childComplexity int, input TagUpdateInput) int
		TagDestroy         func(childComplexity int, input TagDestroyInput) int
		ConfigureGeneral   func(childComplexity int, input ConfigGeneralInput) int
	}

	Performer struct {
		Id           func(childComplexity int) int
		Checksum     func(childComplexity int) int
		Name         func(childComplexity int) int
		Url          func(childComplexity int) int
		Twitter      func(childComplexity int) int
		Instagram    func(childComplexity int) int
		Birthdate    func(childComplexity int) int
		Ethnicity    func(childComplexity int) int
		Country      func(childComplexity int) int
		EyeColor     func(childComplexity int) int
		Height       func(childComplexity int) int
		Measurements func(childComplexity int) int
		FakeTits     func(childComplexity int) int
		CareerLength func(childComplexity int) int
		Tattoos      func(childComplexity int) int
		Piercings    func(childComplexity int) int
		Aliases      func(childComplexity int) int
		Favorite     func(childComplexity int) int
		ImagePath    func(childComplexity int) int
		SceneCount   func(childComplexity int) int
		Scenes       func(childComplexity int) int
	}

	Query struct {
		FindScene                   func(childComplexity int, id *string, checksum *string) int
		FindScenes                  func(childComplexity int, scene_filter *SceneFilterType, scene_ids []int, filter *FindFilterType) int
		FindSceneMarkers            func(childComplexity int, scene_marker_filter *SceneMarkerFilterType, filter *FindFilterType) int
		FindPerformer               func(childComplexity int, id string) int
		FindPerformers              func(childComplexity int, performer_filter *PerformerFilterType, filter *FindFilterType) int
		FindStudio                  func(childComplexity int, id string) int
		FindStudios                 func(childComplexity int, filter *FindFilterType) int
		FindGallery                 func(childComplexity int, id string) int
		FindGalleries               func(childComplexity int, filter *FindFilterType) int
		FindTag                     func(childComplexity int, id string) int
		MarkerWall                  func(childComplexity int, q *string) int
		SceneWall                   func(childComplexity int, q *string) int
		MarkerStrings               func(childComplexity int, q *string, sort *string) int
		ValidGalleriesForScene      func(childComplexity int, scene_id *string) int
		Stats                       func(childComplexity int) int
		SceneMarkerTags             func(childComplexity int, scene_id string) int
		ScrapeFreeones              func(childComplexity int, performer_name string) int
		ScrapeFreeonesPerformerList func(childComplexity int, query string) int
		Configuration               func(childComplexity int) int
		Directories                 func(childComplexity int, path *string) int
		MetadataImport              func(childComplexity int) int
		MetadataExport              func(childComplexity int) int
		MetadataScan                func(childComplexity int) int
		MetadataGenerate            func(childComplexity int, input GenerateMetadataInput) int
		MetadataClean               func(childComplexity int) int
		AllPerformers               func(childComplexity int) int
		AllStudios                  func(childComplexity int) int
		AllTags                     func(childComplexity int) int
	}

	Scene struct {
		Id           func(childComplexity int) int
		Checksum     func(childComplexity int) int
		Title        func(childComplexity int) int
		Details      func(childComplexity int) int
		Url          func(childComplexity int) int
		Date         func(childComplexity int) int
		Rating       func(childComplexity int) int
		Path         func(childComplexity int) int
		File         func(childComplexity int) int
		Paths        func(childComplexity int) int
		IsStreamable func(childComplexity int) int
		SceneMarkers func(childComplexity int) int
		Gallery      func(childComplexity int) int
		Studio       func(childComplexity int) int
		Tags         func(childComplexity int) int
		Performers   func(childComplexity int) int
	}

	SceneFileType struct {
		Size       func(childComplexity int) int
		Duration   func(childComplexity int) int
		VideoCodec func(childComplexity int) int
		AudioCodec func(childComplexity int) int
		Width      func(childComplexity int) int
		Height     func(childComplexity int) int
		Framerate  func(childComplexity int) int
		Bitrate    func(childComplexity int) int
	}

	SceneMarker struct {
		Id         func(childComplexity int) int
		Scene      func(childComplexity int) int
		Title      func(childComplexity int) int
		Seconds    func(childComplexity int) int
		PrimaryTag func(childComplexity int) int
		Tags       func(childComplexity int) int
		Stream     func(childComplexity int) int
		Preview    func(childComplexity int) int
	}

	SceneMarkerTag struct {
		Tag          func(childComplexity int) int
		SceneMarkers func(childComplexity int) int
	}

	ScenePathsType struct {
		Screenshot  func(childComplexity int) int
		Preview     func(childComplexity int) int
		Stream      func(childComplexity int) int
		Webp        func(childComplexity int) int
		Vtt         func(childComplexity int) int
		ChaptersVtt func(childComplexity int) int
	}

	ScrapedPerformer struct {
		Name         func(childComplexity int) int
		Url          func(childComplexity int) int
		Twitter      func(childComplexity int) int
		Instagram    func(childComplexity int) int
		Birthdate    func(childComplexity int) int
		Ethnicity    func(childComplexity int) int
		Country      func(childComplexity int) int
		EyeColor     func(childComplexity int) int
		Height       func(childComplexity int) int
		Measurements func(childComplexity int) int
		FakeTits     func(childComplexity int) int
		CareerLength func(childComplexity int) int
		Tattoos      func(childComplexity int) int
		Piercings    func(childComplexity int) int
		Aliases      func(childComplexity int) int
	}

	StatsResultType struct {
		SceneCount     func(childComplexity int) int
		GalleryCount   func(childComplexity int) int
		PerformerCount func(childComplexity int) int
		StudioCount    func(childComplexity int) int
		TagCount       func(childComplexity int) int
	}

	Studio struct {
		Id         func(childComplexity int) int
		Checksum   func(childComplexity int) int
		Name       func(childComplexity int) int
		Url        func(childComplexity int) int
		ImagePath  func(childComplexity int) int
		SceneCount func(childComplexity int) int
	}

	Subscription struct {
		MetadataUpdate func(childComplexity int) int
	}

	Tag struct {
		Id               func(childComplexity int) int
		Name             func(childComplexity int) int
		SceneCount       func(childComplexity int) int
		SceneMarkerCount func(childComplexity int) int
	}
}

type GalleryResolver interface {
	ID(ctx context.Context, obj *Gallery) (string, error)

	Title(ctx context.Context, obj *Gallery) (*string, error)
	Files(ctx context.Context, obj *Gallery) ([]GalleryFilesType, error)
}
type MutationResolver interface {
	SceneUpdate(ctx context.Context, input SceneUpdateInput) (*Scene, error)
	SceneMarkerCreate(ctx context.Context, input SceneMarkerCreateInput) (*SceneMarker, error)
	SceneMarkerUpdate(ctx context.Context, input SceneMarkerUpdateInput) (*SceneMarker, error)
	SceneMarkerDestroy(ctx context.Context, id string) (bool, error)
	PerformerCreate(ctx context.Context, input PerformerCreateInput) (*Performer, error)
	PerformerUpdate(ctx context.Context, input PerformerUpdateInput) (*Performer, error)
	StudioCreate(ctx context.Context, input StudioCreateInput) (*Studio, error)
	StudioUpdate(ctx context.Context, input StudioUpdateInput) (*Studio, error)
	TagCreate(ctx context.Context, input TagCreateInput) (*Tag, error)
	TagUpdate(ctx context.Context, input TagUpdateInput) (*Tag, error)
	TagDestroy(ctx context.Context, input TagDestroyInput) (bool, error)
	ConfigureGeneral(ctx context.Context, input ConfigGeneralInput) (ConfigGeneralResult, error)
}
type PerformerResolver interface {
	ID(ctx context.Context, obj *Performer) (string, error)

	Name(ctx context.Context, obj *Performer) (*string, error)
	URL(ctx context.Context, obj *Performer) (*string, error)
	Twitter(ctx context.Context, obj *Performer) (*string, error)
	Instagram(ctx context.Context, obj *Performer) (*string, error)
	Birthdate(ctx context.Context, obj *Performer) (*string, error)
	Ethnicity(ctx context.Context, obj *Performer) (*string, error)
	Country(ctx context.Context, obj *Performer) (*string, error)
	EyeColor(ctx context.Context, obj *Performer) (*string, error)
	Height(ctx context.Context, obj *Performer) (*string, error)
	Measurements(ctx context.Context, obj *Performer) (*string, error)
	FakeTits(ctx context.Context, obj *Performer) (*string, error)
	CareerLength(ctx context.Context, obj *Performer) (*string, error)
	Tattoos(ctx context.Context, obj *Performer) (*string, error)
	Piercings(ctx context.Context, obj *Performer) (*string, error)
	Aliases(ctx context.Context, obj *Performer) (*string, error)
	Favorite(ctx context.Context, obj *Performer) (bool, error)
	ImagePath(ctx context.Context, obj *Performer) (*string, error)
	SceneCount(ctx context.Context, obj *Performer) (*int, error)
	Scenes(ctx context.Context, obj *Performer) ([]Scene, error)
}
type QueryResolver interface {
	FindScene(ctx context.Context, id *string, checksum *string) (*Scene, error)
	FindScenes(ctx context.Context, scene_filter *SceneFilterType, scene_ids []int, filter *FindFilterType) (FindScenesResultType, error)
	FindSceneMarkers(ctx context.Context, scene_marker_filter *SceneMarkerFilterType, filter *FindFilterType) (FindSceneMarkersResultType, error)
	FindPerformer(ctx context.Context, id string) (*Performer, error)
	FindPerformers(ctx context.Context, performer_filter *PerformerFilterType, filter *FindFilterType) (FindPerformersResultType, error)
	FindStudio(ctx context.Context, id string) (*Studio, error)
	FindStudios(ctx context.Context, filter *FindFilterType) (FindStudiosResultType, error)
	FindGallery(ctx context.Context, id string) (*Gallery, error)
	FindGalleries(ctx context.Context, filter *FindFilterType) (FindGalleriesResultType, error)
	FindTag(ctx context.Context, id string) (*Tag, error)
	MarkerWall(ctx context.Context, q *string) ([]SceneMarker, error)
	SceneWall(ctx context.Context, q *string) ([]Scene, error)
	MarkerStrings(ctx context.Context, q *string, sort *string) ([]*MarkerStringsResultType, error)
	ValidGalleriesForScene(ctx context.Context, scene_id *string) ([]Gallery, error)
	Stats(ctx context.Context) (StatsResultType, error)
	SceneMarkerTags(ctx context.Context, scene_id string) ([]SceneMarkerTag, error)
	ScrapeFreeones(ctx context.Context, performer_name string) (*ScrapedPerformer, error)
	ScrapeFreeonesPerformerList(ctx context.Context, query string) ([]string, error)
	Configuration(ctx context.Context) (ConfigResult, error)
	Directories(ctx context.Context, path *string) ([]string, error)
	MetadataImport(ctx context.Context) (string, error)
	MetadataExport(ctx context.Context) (string, error)
	MetadataScan(ctx context.Context) (string, error)
	MetadataGenerate(ctx context.Context, input GenerateMetadataInput) (string, error)
	MetadataClean(ctx context.Context) (string, error)
	AllPerformers(ctx context.Context) ([]Performer, error)
	AllStudios(ctx context.Context) ([]Studio, error)
	AllTags(ctx context.Context) ([]Tag, error)
}
type SceneResolver interface {
	ID(ctx context.Context, obj *Scene) (string, error)

	Title(ctx context.Context, obj *Scene) (*string, error)
	Details(ctx context.Context, obj *Scene) (*string, error)
	URL(ctx context.Context, obj *Scene) (*string, error)
	Date(ctx context.Context, obj *Scene) (*string, error)
	Rating(ctx context.Context, obj *Scene) (*int, error)

	File(ctx context.Context, obj *Scene) (SceneFileType, error)
	Paths(ctx context.Context, obj *Scene) (ScenePathsType, error)
	IsStreamable(ctx context.Context, obj *Scene) (bool, error)
	SceneMarkers(ctx context.Context, obj *Scene) ([]SceneMarker, error)
	Gallery(ctx context.Context, obj *Scene) (*Gallery, error)
	Studio(ctx context.Context, obj *Scene) (*Studio, error)
	Tags(ctx context.Context, obj *Scene) ([]Tag, error)
	Performers(ctx context.Context, obj *Scene) ([]Performer, error)
}
type SceneMarkerResolver interface {
	ID(ctx context.Context, obj *SceneMarker) (string, error)
	Scene(ctx context.Context, obj *SceneMarker) (Scene, error)

	PrimaryTag(ctx context.Context, obj *SceneMarker) (Tag, error)
	Tags(ctx context.Context, obj *SceneMarker) ([]Tag, error)
	Stream(ctx context.Context, obj *SceneMarker) (string, error)
	Preview(ctx context.Context, obj *SceneMarker) (string, error)
}
type StudioResolver interface {
	ID(ctx context.Context, obj *Studio) (string, error)

	Name(ctx context.Context, obj *Studio) (string, error)
	URL(ctx context.Context, obj *Studio) (*string, error)
	ImagePath(ctx context.Context, obj *Studio) (*string, error)
	SceneCount(ctx context.Context, obj *Studio) (*int, error)
}
type SubscriptionResolver interface {
	MetadataUpdate(ctx context.Context) (<-chan string, error)
}
type TagResolver interface {
	ID(ctx context.Context, obj *Tag) (string, error)

	SceneCount(ctx context.Context, obj *Tag) (*int, error)
	SceneMarkerCount(ctx context.Context, obj *Tag) (*int, error)
}

func (e *executableSchema) field_Mutation_sceneUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 SceneUpdateInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalSceneUpdateInput(tmp)
		if err != nil {
			return nil, err
		}

		mSceneUpdateInput1, err := e.SceneUpdateInputMiddleware(ctx, &arg0)
		if err != nil {
			return nil, err
		}
		arg0 = *mSceneUpdateInput1
	}
	args["input"] = arg0
	return args, nil

}

func (e *executableSchema) field_Mutation_sceneMarkerCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 SceneMarkerCreateInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalSceneMarkerCreateInput(tmp)
		if err != nil {
			return nil, err
		}

		mSceneMarkerCreateInput1, err := e.SceneMarkerCreateInputMiddleware(ctx, &arg0)
		if err != nil {
			return nil, err
		}
		arg0 = *mSceneMarkerCreateInput1
	}
	args["input"] = arg0
	return args, nil

}

func (e *executableSchema) field_Mutation_sceneMarkerUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 SceneMarkerUpdateInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalSceneMarkerUpdateInput(tmp)
		if err != nil {
			return nil, err
		}

		mSceneMarkerUpdateInput1, err := e.SceneMarkerUpdateInputMiddleware(ctx, &arg0)
		if err != nil {
			return nil, err
		}
		arg0 = *mSceneMarkerUpdateInput1
	}
	args["input"] = arg0
	return args, nil

}

func (e *executableSchema) field_Mutation_sceneMarkerDestroy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func (e *executableSchema) field_Mutation_performerCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 PerformerCreateInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalPerformerCreateInput(tmp)
		if err != nil {
			return nil, err
		}

		mPerformerCreateInput1, err := e.PerformerCreateInputMiddleware(ctx, &arg0)
		if err != nil {
			return nil, err
		}
		arg0 = *mPerformerCreateInput1
	}
	args["input"] = arg0
	return args, nil

}

func (e *executableSchema) field_Mutation_performerUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 PerformerUpdateInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalPerformerUpdateInput(tmp)
		if err != nil {
			return nil, err
		}

		mPerformerUpdateInput1, err := e.PerformerUpdateInputMiddleware(ctx, &arg0)
		if err != nil {
			return nil, err
		}
		arg0 = *mPerformerUpdateInput1
	}
	args["input"] = arg0
	return args, nil

}

func (e *executableSchema) field_Mutation_studioCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 StudioCreateInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalStudioCreateInput(tmp)
		if err != nil {
			return nil, err
		}

		mStudioCreateInput1, err := e.StudioCreateInputMiddleware(ctx, &arg0)
		if err != nil {
			return nil, err
		}
		arg0 = *mStudioCreateInput1
	}
	args["input"] = arg0
	return args, nil

}

func (e *executableSchema) field_Mutation_studioUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 StudioUpdateInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalStudioUpdateInput(tmp)
		if err != nil {
			return nil, err
		}

		mStudioUpdateInput1, err := e.StudioUpdateInputMiddleware(ctx, &arg0)
		if err != nil {
			return nil, err
		}
		arg0 = *mStudioUpdateInput1
	}
	args["input"] = arg0
	return args, nil

}

func (e *executableSchema) field_Mutation_tagCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 TagCreateInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalTagCreateInput(tmp)
		if err != nil {
			return nil, err
		}

		mTagCreateInput1, err := e.TagCreateInputMiddleware(ctx, &arg0)
		if err != nil {
			return nil, err
		}
		arg0 = *mTagCreateInput1
	}
	args["input"] = arg0
	return args, nil

}

func (e *executableSchema) field_Mutation_tagUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 TagUpdateInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalTagUpdateInput(tmp)
		if err != nil {
			return nil, err
		}

		mTagUpdateInput1, err := e.TagUpdateInputMiddleware(ctx, &arg0)
		if err != nil {
			return nil, err
		}
		arg0 = *mTagUpdateInput1
	}
	args["input"] = arg0
	return args, nil

}

func (e *executableSchema) field_Mutation_tagDestroy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 TagDestroyInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalTagDestroyInput(tmp)
		if err != nil {
			return nil, err
		}

		mTagDestroyInput1, err := e.TagDestroyInputMiddleware(ctx, &arg0)
		if err != nil {
			return nil, err
		}
		arg0 = *mTagDestroyInput1
	}
	args["input"] = arg0
	return args, nil

}

func (e *executableSchema) field_Mutation_configureGeneral_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 ConfigGeneralInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalConfigGeneralInput(tmp)
		if err != nil {
			return nil, err
		}

		mConfigGeneralInput1, err := e.ConfigGeneralInputMiddleware(ctx, &arg0)
		if err != nil {
			return nil, err
		}
		arg0 = *mConfigGeneralInput1
	}
	args["input"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_findScene_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalID(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["checksum"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["checksum"] = arg1
	return args, nil

}

func (e *executableSchema) field_Query_findScenes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *SceneFilterType
	if tmp, ok := rawArgs["scene_filter"]; ok {
		var err error
		var ptr1 SceneFilterType
		if tmp != nil {
			ptr1, err = UnmarshalSceneFilterType(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}

		if arg0 != nil {
			var err error
			arg0, err = e.SceneFilterTypeMiddleware(ctx, arg0)
			if err != nil {
				return nil, err
			}
		}
	}
	args["scene_filter"] = arg0
	var arg1 []int
	if tmp, ok := rawArgs["scene_ids"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg1 = make([]int, len(rawIf1))
		for idx1 := range rawIf1 {
			arg1[idx1], err = graphql.UnmarshalInt(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["scene_ids"] = arg1
	var arg2 *FindFilterType
	if tmp, ok := rawArgs["filter"]; ok {
		var err error
		var ptr1 FindFilterType
		if tmp != nil {
			ptr1, err = UnmarshalFindFilterType(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}

		if arg2 != nil {
			var err error
			arg2, err = e.FindFilterTypeMiddleware(ctx, arg2)
			if err != nil {
				return nil, err
			}
		}
	}
	args["filter"] = arg2
	return args, nil

}

func (e *executableSchema) field_Query_findSceneMarkers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *SceneMarkerFilterType
	if tmp, ok := rawArgs["scene_marker_filter"]; ok {
		var err error
		var ptr1 SceneMarkerFilterType
		if tmp != nil {
			ptr1, err = UnmarshalSceneMarkerFilterType(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}

		if arg0 != nil {
			var err error
			arg0, err = e.SceneMarkerFilterTypeMiddleware(ctx, arg0)
			if err != nil {
				return nil, err
			}
		}
	}
	args["scene_marker_filter"] = arg0
	var arg1 *FindFilterType
	if tmp, ok := rawArgs["filter"]; ok {
		var err error
		var ptr1 FindFilterType
		if tmp != nil {
			ptr1, err = UnmarshalFindFilterType(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}

		if arg1 != nil {
			var err error
			arg1, err = e.FindFilterTypeMiddleware(ctx, arg1)
			if err != nil {
				return nil, err
			}
		}
	}
	args["filter"] = arg1
	return args, nil

}

func (e *executableSchema) field_Query_findPerformer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_findPerformers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *PerformerFilterType
	if tmp, ok := rawArgs["performer_filter"]; ok {
		var err error
		var ptr1 PerformerFilterType
		if tmp != nil {
			ptr1, err = UnmarshalPerformerFilterType(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}

		if arg0 != nil {
			var err error
			arg0, err = e.PerformerFilterTypeMiddleware(ctx, arg0)
			if err != nil {
				return nil, err
			}
		}
	}
	args["performer_filter"] = arg0
	var arg1 *FindFilterType
	if tmp, ok := rawArgs["filter"]; ok {
		var err error
		var ptr1 FindFilterType
		if tmp != nil {
			ptr1, err = UnmarshalFindFilterType(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}

		if arg1 != nil {
			var err error
			arg1, err = e.FindFilterTypeMiddleware(ctx, arg1)
			if err != nil {
				return nil, err
			}
		}
	}
	args["filter"] = arg1
	return args, nil

}

func (e *executableSchema) field_Query_findStudio_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_findStudios_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *FindFilterType
	if tmp, ok := rawArgs["filter"]; ok {
		var err error
		var ptr1 FindFilterType
		if tmp != nil {
			ptr1, err = UnmarshalFindFilterType(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}

		if arg0 != nil {
			var err error
			arg0, err = e.FindFilterTypeMiddleware(ctx, arg0)
			if err != nil {
				return nil, err
			}
		}
	}
	args["filter"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_findGallery_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_findGalleries_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *FindFilterType
	if tmp, ok := rawArgs["filter"]; ok {
		var err error
		var ptr1 FindFilterType
		if tmp != nil {
			ptr1, err = UnmarshalFindFilterType(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}

		if arg0 != nil {
			var err error
			arg0, err = e.FindFilterTypeMiddleware(ctx, arg0)
			if err != nil {
				return nil, err
			}
		}
	}
	args["filter"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_findTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_markerWall_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["q"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["q"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_sceneWall_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["q"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["q"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_markerStrings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["q"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["q"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["sort"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["sort"] = arg1
	return args, nil

}

func (e *executableSchema) field_Query_validGalleriesForScene_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["scene_id"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalID(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["scene_id"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_sceneMarkerTags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["scene_id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["scene_id"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_scrapeFreeones_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["performer_name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["performer_name"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_scrapeFreeonesPerformerList_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["query"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_directories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["path"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query_metadataGenerate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 GenerateMetadataInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalGenerateMetadataInput(tmp)
		if err != nil {
			return nil, err
		}

		mGenerateMetadataInput1, err := e.GenerateMetadataInputMiddleware(ctx, &arg0)
		if err != nil {
			return nil, err
		}
		arg0 = *mGenerateMetadataInput1
	}
	args["input"] = arg0
	return args, nil

}

func (e *executableSchema) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func (e *executableSchema) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func (e *executableSchema) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	switch typeName + "." + field {

	case "ConfigGeneralResult.stashes":
		if e.complexity.ConfigGeneralResult.Stashes == nil {
			break
		}

		return e.complexity.ConfigGeneralResult.Stashes(childComplexity), true

	case "ConfigGeneralResult.databasePath":
		if e.complexity.ConfigGeneralResult.DatabasePath == nil {
			break
		}

		return e.complexity.ConfigGeneralResult.DatabasePath(childComplexity), true

	case "ConfigGeneralResult.generatedPath":
		if e.complexity.ConfigGeneralResult.GeneratedPath == nil {
			break
		}

		return e.complexity.ConfigGeneralResult.GeneratedPath(childComplexity), true

	case "ConfigResult.general":
		if e.complexity.ConfigResult.General == nil {
			break
		}

		return e.complexity.ConfigResult.General(childComplexity), true

	case "FindGalleriesResultType.count":
		if e.complexity.FindGalleriesResultType.Count == nil {
			break
		}

		return e.complexity.FindGalleriesResultType.Count(childComplexity), true

	case "FindGalleriesResultType.galleries":
		if e.complexity.FindGalleriesResultType.Galleries == nil {
			break
		}

		return e.complexity.FindGalleriesResultType.Galleries(childComplexity), true

	case "FindPerformersResultType.count":
		if e.complexity.FindPerformersResultType.Count == nil {
			break
		}

		return e.complexity.FindPerformersResultType.Count(childComplexity), true

	case "FindPerformersResultType.performers":
		if e.complexity.FindPerformersResultType.Performers == nil {
			break
		}

		return e.complexity.FindPerformersResultType.Performers(childComplexity), true

	case "FindSceneMarkersResultType.count":
		if e.complexity.FindSceneMarkersResultType.Count == nil {
			break
		}

		return e.complexity.FindSceneMarkersResultType.Count(childComplexity), true

	case "FindSceneMarkersResultType.scene_markers":
		if e.complexity.FindSceneMarkersResultType.SceneMarkers == nil {
			break
		}

		return e.complexity.FindSceneMarkersResultType.SceneMarkers(childComplexity), true

	case "FindScenesResultType.count":
		if e.complexity.FindScenesResultType.Count == nil {
			break
		}

		return e.complexity.FindScenesResultType.Count(childComplexity), true

	case "FindScenesResultType.scenes":
		if e.complexity.FindScenesResultType.Scenes == nil {
			break
		}

		return e.complexity.FindScenesResultType.Scenes(childComplexity), true

	case "FindStudiosResultType.count":
		if e.complexity.FindStudiosResultType.Count == nil {
			break
		}

		return e.complexity.FindStudiosResultType.Count(childComplexity), true

	case "FindStudiosResultType.studios":
		if e.complexity.FindStudiosResultType.Studios == nil {
			break
		}

		return e.complexity.FindStudiosResultType.Studios(childComplexity), true

	case "Gallery.id":
		if e.complexity.Gallery.Id == nil {
			break
		}

		return e.complexity.Gallery.Id(childComplexity), true

	case "Gallery.checksum":
		if e.complexity.Gallery.Checksum == nil {
			break
		}

		return e.complexity.Gallery.Checksum(childComplexity), true

	case "Gallery.path":
		if e.complexity.Gallery.Path == nil {
			break
		}

		return e.complexity.Gallery.Path(childComplexity), true

	case "Gallery.title":
		if e.complexity.Gallery.Title == nil {
			break
		}

		return e.complexity.Gallery.Title(childComplexity), true

	case "Gallery.files":
		if e.complexity.Gallery.Files == nil {
			break
		}

		return e.complexity.Gallery.Files(childComplexity), true

	case "GalleryFilesType.index":
		if e.complexity.GalleryFilesType.Index == nil {
			break
		}

		return e.complexity.GalleryFilesType.Index(childComplexity), true

	case "GalleryFilesType.name":
		if e.complexity.GalleryFilesType.Name == nil {
			break
		}

		return e.complexity.GalleryFilesType.Name(childComplexity), true

	case "GalleryFilesType.path":
		if e.complexity.GalleryFilesType.Path == nil {
			break
		}

		return e.complexity.GalleryFilesType.Path(childComplexity), true

	case "MarkerStringsResultType.count":
		if e.complexity.MarkerStringsResultType.Count == nil {
			break
		}

		return e.complexity.MarkerStringsResultType.Count(childComplexity), true

	case "MarkerStringsResultType.id":
		if e.complexity.MarkerStringsResultType.Id == nil {
			break
		}

		return e.complexity.MarkerStringsResultType.Id(childComplexity), true

	case "MarkerStringsResultType.title":
		if e.complexity.MarkerStringsResultType.Title == nil {
			break
		}

		return e.complexity.MarkerStringsResultType.Title(childComplexity), true

	case "Mutation.sceneUpdate":
		if e.complexity.Mutation.SceneUpdate == nil {
			break
		}

		args, err := e.field_Mutation_sceneUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SceneUpdate(childComplexity, args["input"].(SceneUpdateInput)), true

	case "Mutation.sceneMarkerCreate":
		if e.complexity.Mutation.SceneMarkerCreate == nil {
			break
		}

		args, err := e.field_Mutation_sceneMarkerCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SceneMarkerCreate(childComplexity, args["input"].(SceneMarkerCreateInput)), true

	case "Mutation.sceneMarkerUpdate":
		if e.complexity.Mutation.SceneMarkerUpdate == nil {
			break
		}

		args, err := e.field_Mutation_sceneMarkerUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SceneMarkerUpdate(childComplexity, args["input"].(SceneMarkerUpdateInput)), true

	case "Mutation.sceneMarkerDestroy":
		if e.complexity.Mutation.SceneMarkerDestroy == nil {
			break
		}

		args, err := e.field_Mutation_sceneMarkerDestroy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SceneMarkerDestroy(childComplexity, args["id"].(string)), true

	case "Mutation.performerCreate":
		if e.complexity.Mutation.PerformerCreate == nil {
			break
		}

		args, err := e.field_Mutation_performerCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PerformerCreate(childComplexity, args["input"].(PerformerCreateInput)), true

	case "Mutation.performerUpdate":
		if e.complexity.Mutation.PerformerUpdate == nil {
			break
		}

		args, err := e.field_Mutation_performerUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PerformerUpdate(childComplexity, args["input"].(PerformerUpdateInput)), true

	case "Mutation.studioCreate":
		if e.complexity.Mutation.StudioCreate == nil {
			break
		}

		args, err := e.field_Mutation_studioCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StudioCreate(childComplexity, args["input"].(StudioCreateInput)), true

	case "Mutation.studioUpdate":
		if e.complexity.Mutation.StudioUpdate == nil {
			break
		}

		args, err := e.field_Mutation_studioUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StudioUpdate(childComplexity, args["input"].(StudioUpdateInput)), true

	case "Mutation.tagCreate":
		if e.complexity.Mutation.TagCreate == nil {
			break
		}

		args, err := e.field_Mutation_tagCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TagCreate(childComplexity, args["input"].(TagCreateInput)), true

	case "Mutation.tagUpdate":
		if e.complexity.Mutation.TagUpdate == nil {
			break
		}

		args, err := e.field_Mutation_tagUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TagUpdate(childComplexity, args["input"].(TagUpdateInput)), true

	case "Mutation.tagDestroy":
		if e.complexity.Mutation.TagDestroy == nil {
			break
		}

		args, err := e.field_Mutation_tagDestroy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TagDestroy(childComplexity, args["input"].(TagDestroyInput)), true

	case "Mutation.configureGeneral":
		if e.complexity.Mutation.ConfigureGeneral == nil {
			break
		}

		args, err := e.field_Mutation_configureGeneral_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfigureGeneral(childComplexity, args["input"].(ConfigGeneralInput)), true

	case "Performer.id":
		if e.complexity.Performer.Id == nil {
			break
		}

		return e.complexity.Performer.Id(childComplexity), true

	case "Performer.checksum":
		if e.complexity.Performer.Checksum == nil {
			break
		}

		return e.complexity.Performer.Checksum(childComplexity), true

	case "Performer.name":
		if e.complexity.Performer.Name == nil {
			break
		}

		return e.complexity.Performer.Name(childComplexity), true

	case "Performer.url":
		if e.complexity.Performer.Url == nil {
			break
		}

		return e.complexity.Performer.Url(childComplexity), true

	case "Performer.twitter":
		if e.complexity.Performer.Twitter == nil {
			break
		}

		return e.complexity.Performer.Twitter(childComplexity), true

	case "Performer.instagram":
		if e.complexity.Performer.Instagram == nil {
			break
		}

		return e.complexity.Performer.Instagram(childComplexity), true

	case "Performer.birthdate":
		if e.complexity.Performer.Birthdate == nil {
			break
		}

		return e.complexity.Performer.Birthdate(childComplexity), true

	case "Performer.ethnicity":
		if e.complexity.Performer.Ethnicity == nil {
			break
		}

		return e.complexity.Performer.Ethnicity(childComplexity), true

	case "Performer.country":
		if e.complexity.Performer.Country == nil {
			break
		}

		return e.complexity.Performer.Country(childComplexity), true

	case "Performer.eye_color":
		if e.complexity.Performer.EyeColor == nil {
			break
		}

		return e.complexity.Performer.EyeColor(childComplexity), true

	case "Performer.height":
		if e.complexity.Performer.Height == nil {
			break
		}

		return e.complexity.Performer.Height(childComplexity), true

	case "Performer.measurements":
		if e.complexity.Performer.Measurements == nil {
			break
		}

		return e.complexity.Performer.Measurements(childComplexity), true

	case "Performer.fake_tits":
		if e.complexity.Performer.FakeTits == nil {
			break
		}

		return e.complexity.Performer.FakeTits(childComplexity), true

	case "Performer.career_length":
		if e.complexity.Performer.CareerLength == nil {
			break
		}

		return e.complexity.Performer.CareerLength(childComplexity), true

	case "Performer.tattoos":
		if e.complexity.Performer.Tattoos == nil {
			break
		}

		return e.complexity.Performer.Tattoos(childComplexity), true

	case "Performer.piercings":
		if e.complexity.Performer.Piercings == nil {
			break
		}

		return e.complexity.Performer.Piercings(childComplexity), true

	case "Performer.aliases":
		if e.complexity.Performer.Aliases == nil {
			break
		}

		return e.complexity.Performer.Aliases(childComplexity), true

	case "Performer.favorite":
		if e.complexity.Performer.Favorite == nil {
			break
		}

		return e.complexity.Performer.Favorite(childComplexity), true

	case "Performer.image_path":
		if e.complexity.Performer.ImagePath == nil {
			break
		}

		return e.complexity.Performer.ImagePath(childComplexity), true

	case "Performer.scene_count":
		if e.complexity.Performer.SceneCount == nil {
			break
		}

		return e.complexity.Performer.SceneCount(childComplexity), true

	case "Performer.scenes":
		if e.complexity.Performer.Scenes == nil {
			break
		}

		return e.complexity.Performer.Scenes(childComplexity), true

	case "Query.findScene":
		if e.complexity.Query.FindScene == nil {
			break
		}

		args, err := e.field_Query_findScene_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindScene(childComplexity, args["id"].(*string), args["checksum"].(*string)), true

	case "Query.findScenes":
		if e.complexity.Query.FindScenes == nil {
			break
		}

		args, err := e.field_Query_findScenes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindScenes(childComplexity, args["scene_filter"].(*SceneFilterType), args["scene_ids"].([]int), args["filter"].(*FindFilterType)), true

	case "Query.findSceneMarkers":
		if e.complexity.Query.FindSceneMarkers == nil {
			break
		}

		args, err := e.field_Query_findSceneMarkers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindSceneMarkers(childComplexity, args["scene_marker_filter"].(*SceneMarkerFilterType), args["filter"].(*FindFilterType)), true

	case "Query.findPerformer":
		if e.complexity.Query.FindPerformer == nil {
			break
		}

		args, err := e.field_Query_findPerformer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindPerformer(childComplexity, args["id"].(string)), true

	case "Query.findPerformers":
		if e.complexity.Query.FindPerformers == nil {
			break
		}

		args, err := e.field_Query_findPerformers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindPerformers(childComplexity, args["performer_filter"].(*PerformerFilterType), args["filter"].(*FindFilterType)), true

	case "Query.findStudio":
		if e.complexity.Query.FindStudio == nil {
			break
		}

		args, err := e.field_Query_findStudio_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindStudio(childComplexity, args["id"].(string)), true

	case "Query.findStudios":
		if e.complexity.Query.FindStudios == nil {
			break
		}

		args, err := e.field_Query_findStudios_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindStudios(childComplexity, args["filter"].(*FindFilterType)), true

	case "Query.findGallery":
		if e.complexity.Query.FindGallery == nil {
			break
		}

		args, err := e.field_Query_findGallery_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindGallery(childComplexity, args["id"].(string)), true

	case "Query.findGalleries":
		if e.complexity.Query.FindGalleries == nil {
			break
		}

		args, err := e.field_Query_findGalleries_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindGalleries(childComplexity, args["filter"].(*FindFilterType)), true

	case "Query.findTag":
		if e.complexity.Query.FindTag == nil {
			break
		}

		args, err := e.field_Query_findTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindTag(childComplexity, args["id"].(string)), true

	case "Query.markerWall":
		if e.complexity.Query.MarkerWall == nil {
			break
		}

		args, err := e.field_Query_markerWall_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarkerWall(childComplexity, args["q"].(*string)), true

	case "Query.sceneWall":
		if e.complexity.Query.SceneWall == nil {
			break
		}

		args, err := e.field_Query_sceneWall_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SceneWall(childComplexity, args["q"].(*string)), true

	case "Query.markerStrings":
		if e.complexity.Query.MarkerStrings == nil {
			break
		}

		args, err := e.field_Query_markerStrings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarkerStrings(childComplexity, args["q"].(*string), args["sort"].(*string)), true

	case "Query.validGalleriesForScene":
		if e.complexity.Query.ValidGalleriesForScene == nil {
			break
		}

		args, err := e.field_Query_validGalleriesForScene_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ValidGalleriesForScene(childComplexity, args["scene_id"].(*string)), true

	case "Query.stats":
		if e.complexity.Query.Stats == nil {
			break
		}

		return e.complexity.Query.Stats(childComplexity), true

	case "Query.sceneMarkerTags":
		if e.complexity.Query.SceneMarkerTags == nil {
			break
		}

		args, err := e.field_Query_sceneMarkerTags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SceneMarkerTags(childComplexity, args["scene_id"].(string)), true

	case "Query.scrapeFreeones":
		if e.complexity.Query.ScrapeFreeones == nil {
			break
		}

		args, err := e.field_Query_scrapeFreeones_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ScrapeFreeones(childComplexity, args["performer_name"].(string)), true

	case "Query.scrapeFreeonesPerformerList":
		if e.complexity.Query.ScrapeFreeonesPerformerList == nil {
			break
		}

		args, err := e.field_Query_scrapeFreeonesPerformerList_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ScrapeFreeonesPerformerList(childComplexity, args["query"].(string)), true

	case "Query.configuration":
		if e.complexity.Query.Configuration == nil {
			break
		}

		return e.complexity.Query.Configuration(childComplexity), true

	case "Query.directories":
		if e.complexity.Query.Directories == nil {
			break
		}

		args, err := e.field_Query_directories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Directories(childComplexity, args["path"].(*string)), true

	case "Query.metadataImport":
		if e.complexity.Query.MetadataImport == nil {
			break
		}

		return e.complexity.Query.MetadataImport(childComplexity), true

	case "Query.metadataExport":
		if e.complexity.Query.MetadataExport == nil {
			break
		}

		return e.complexity.Query.MetadataExport(childComplexity), true

	case "Query.metadataScan":
		if e.complexity.Query.MetadataScan == nil {
			break
		}

		return e.complexity.Query.MetadataScan(childComplexity), true

	case "Query.metadataGenerate":
		if e.complexity.Query.MetadataGenerate == nil {
			break
		}

		args, err := e.field_Query_metadataGenerate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MetadataGenerate(childComplexity, args["input"].(GenerateMetadataInput)), true

	case "Query.metadataClean":
		if e.complexity.Query.MetadataClean == nil {
			break
		}

		return e.complexity.Query.MetadataClean(childComplexity), true

	case "Query.allPerformers":
		if e.complexity.Query.AllPerformers == nil {
			break
		}

		return e.complexity.Query.AllPerformers(childComplexity), true

	case "Query.allStudios":
		if e.complexity.Query.AllStudios == nil {
			break
		}

		return e.complexity.Query.AllStudios(childComplexity), true

	case "Query.allTags":
		if e.complexity.Query.AllTags == nil {
			break
		}

		return e.complexity.Query.AllTags(childComplexity), true

	case "Scene.id":
		if e.complexity.Scene.Id == nil {
			break
		}

		return e.complexity.Scene.Id(childComplexity), true

	case "Scene.checksum":
		if e.complexity.Scene.Checksum == nil {
			break
		}

		return e.complexity.Scene.Checksum(childComplexity), true

	case "Scene.title":
		if e.complexity.Scene.Title == nil {
			break
		}

		return e.complexity.Scene.Title(childComplexity), true

	case "Scene.details":
		if e.complexity.Scene.Details == nil {
			break
		}

		return e.complexity.Scene.Details(childComplexity), true

	case "Scene.url":
		if e.complexity.Scene.Url == nil {
			break
		}

		return e.complexity.Scene.Url(childComplexity), true

	case "Scene.date":
		if e.complexity.Scene.Date == nil {
			break
		}

		return e.complexity.Scene.Date(childComplexity), true

	case "Scene.rating":
		if e.complexity.Scene.Rating == nil {
			break
		}

		return e.complexity.Scene.Rating(childComplexity), true

	case "Scene.path":
		if e.complexity.Scene.Path == nil {
			break
		}

		return e.complexity.Scene.Path(childComplexity), true

	case "Scene.file":
		if e.complexity.Scene.File == nil {
			break
		}

		return e.complexity.Scene.File(childComplexity), true

	case "Scene.paths":
		if e.complexity.Scene.Paths == nil {
			break
		}

		return e.complexity.Scene.Paths(childComplexity), true

	case "Scene.is_streamable":
		if e.complexity.Scene.IsStreamable == nil {
			break
		}

		return e.complexity.Scene.IsStreamable(childComplexity), true

	case "Scene.scene_markers":
		if e.complexity.Scene.SceneMarkers == nil {
			break
		}

		return e.complexity.Scene.SceneMarkers(childComplexity), true

	case "Scene.gallery":
		if e.complexity.Scene.Gallery == nil {
			break
		}

		return e.complexity.Scene.Gallery(childComplexity), true

	case "Scene.studio":
		if e.complexity.Scene.Studio == nil {
			break
		}

		return e.complexity.Scene.Studio(childComplexity), true

	case "Scene.tags":
		if e.complexity.Scene.Tags == nil {
			break
		}

		return e.complexity.Scene.Tags(childComplexity), true

	case "Scene.performers":
		if e.complexity.Scene.Performers == nil {
			break
		}

		return e.complexity.Scene.Performers(childComplexity), true

	case "SceneFileType.size":
		if e.complexity.SceneFileType.Size == nil {
			break
		}

		return e.complexity.SceneFileType.Size(childComplexity), true

	case "SceneFileType.duration":
		if e.complexity.SceneFileType.Duration == nil {
			break
		}

		return e.complexity.SceneFileType.Duration(childComplexity), true

	case "SceneFileType.video_codec":
		if e.complexity.SceneFileType.VideoCodec == nil {
			break
		}

		return e.complexity.SceneFileType.VideoCodec(childComplexity), true

	case "SceneFileType.audio_codec":
		if e.complexity.SceneFileType.AudioCodec == nil {
			break
		}

		return e.complexity.SceneFileType.AudioCodec(childComplexity), true

	case "SceneFileType.width":
		if e.complexity.SceneFileType.Width == nil {
			break
		}

		return e.complexity.SceneFileType.Width(childComplexity), true

	case "SceneFileType.height":
		if e.complexity.SceneFileType.Height == nil {
			break
		}

		return e.complexity.SceneFileType.Height(childComplexity), true

	case "SceneFileType.framerate":
		if e.complexity.SceneFileType.Framerate == nil {
			break
		}

		return e.complexity.SceneFileType.Framerate(childComplexity), true

	case "SceneFileType.bitrate":
		if e.complexity.SceneFileType.Bitrate == nil {
			break
		}

		return e.complexity.SceneFileType.Bitrate(childComplexity), true

	case "SceneMarker.id":
		if e.complexity.SceneMarker.Id == nil {
			break
		}

		return e.complexity.SceneMarker.Id(childComplexity), true

	case "SceneMarker.scene":
		if e.complexity.SceneMarker.Scene == nil {
			break
		}

		return e.complexity.SceneMarker.Scene(childComplexity), true

	case "SceneMarker.title":
		if e.complexity.SceneMarker.Title == nil {
			break
		}

		return e.complexity.SceneMarker.Title(childComplexity), true

	case "SceneMarker.seconds":
		if e.complexity.SceneMarker.Seconds == nil {
			break
		}

		return e.complexity.SceneMarker.Seconds(childComplexity), true

	case "SceneMarker.primary_tag":
		if e.complexity.SceneMarker.PrimaryTag == nil {
			break
		}

		return e.complexity.SceneMarker.PrimaryTag(childComplexity), true

	case "SceneMarker.tags":
		if e.complexity.SceneMarker.Tags == nil {
			break
		}

		return e.complexity.SceneMarker.Tags(childComplexity), true

	case "SceneMarker.stream":
		if e.complexity.SceneMarker.Stream == nil {
			break
		}

		return e.complexity.SceneMarker.Stream(childComplexity), true

	case "SceneMarker.preview":
		if e.complexity.SceneMarker.Preview == nil {
			break
		}

		return e.complexity.SceneMarker.Preview(childComplexity), true

	case "SceneMarkerTag.tag":
		if e.complexity.SceneMarkerTag.Tag == nil {
			break
		}

		return e.complexity.SceneMarkerTag.Tag(childComplexity), true

	case "SceneMarkerTag.scene_markers":
		if e.complexity.SceneMarkerTag.SceneMarkers == nil {
			break
		}

		return e.complexity.SceneMarkerTag.SceneMarkers(childComplexity), true

	case "ScenePathsType.screenshot":
		if e.complexity.ScenePathsType.Screenshot == nil {
			break
		}

		return e.complexity.ScenePathsType.Screenshot(childComplexity), true

	case "ScenePathsType.preview":
		if e.complexity.ScenePathsType.Preview == nil {
			break
		}

		return e.complexity.ScenePathsType.Preview(childComplexity), true

	case "ScenePathsType.stream":
		if e.complexity.ScenePathsType.Stream == nil {
			break
		}

		return e.complexity.ScenePathsType.Stream(childComplexity), true

	case "ScenePathsType.webp":
		if e.complexity.ScenePathsType.Webp == nil {
			break
		}

		return e.complexity.ScenePathsType.Webp(childComplexity), true

	case "ScenePathsType.vtt":
		if e.complexity.ScenePathsType.Vtt == nil {
			break
		}

		return e.complexity.ScenePathsType.Vtt(childComplexity), true

	case "ScenePathsType.chapters_vtt":
		if e.complexity.ScenePathsType.ChaptersVtt == nil {
			break
		}

		return e.complexity.ScenePathsType.ChaptersVtt(childComplexity), true

	case "ScrapedPerformer.name":
		if e.complexity.ScrapedPerformer.Name == nil {
			break
		}

		return e.complexity.ScrapedPerformer.Name(childComplexity), true

	case "ScrapedPerformer.url":
		if e.complexity.ScrapedPerformer.Url == nil {
			break
		}

		return e.complexity.ScrapedPerformer.Url(childComplexity), true

	case "ScrapedPerformer.twitter":
		if e.complexity.ScrapedPerformer.Twitter == nil {
			break
		}

		return e.complexity.ScrapedPerformer.Twitter(childComplexity), true

	case "ScrapedPerformer.instagram":
		if e.complexity.ScrapedPerformer.Instagram == nil {
			break
		}

		return e.complexity.ScrapedPerformer.Instagram(childComplexity), true

	case "ScrapedPerformer.birthdate":
		if e.complexity.ScrapedPerformer.Birthdate == nil {
			break
		}

		return e.complexity.ScrapedPerformer.Birthdate(childComplexity), true

	case "ScrapedPerformer.ethnicity":
		if e.complexity.ScrapedPerformer.Ethnicity == nil {
			break
		}

		return e.complexity.ScrapedPerformer.Ethnicity(childComplexity), true

	case "ScrapedPerformer.country":
		if e.complexity.ScrapedPerformer.Country == nil {
			break
		}

		return e.complexity.ScrapedPerformer.Country(childComplexity), true

	case "ScrapedPerformer.eye_color":
		if e.complexity.ScrapedPerformer.EyeColor == nil {
			break
		}

		return e.complexity.ScrapedPerformer.EyeColor(childComplexity), true

	case "ScrapedPerformer.height":
		if e.complexity.ScrapedPerformer.Height == nil {
			break
		}

		return e.complexity.ScrapedPerformer.Height(childComplexity), true

	case "ScrapedPerformer.measurements":
		if e.complexity.ScrapedPerformer.Measurements == nil {
			break
		}

		return e.complexity.ScrapedPerformer.Measurements(childComplexity), true

	case "ScrapedPerformer.fake_tits":
		if e.complexity.ScrapedPerformer.FakeTits == nil {
			break
		}

		return e.complexity.ScrapedPerformer.FakeTits(childComplexity), true

	case "ScrapedPerformer.career_length":
		if e.complexity.ScrapedPerformer.CareerLength == nil {
			break
		}

		return e.complexity.ScrapedPerformer.CareerLength(childComplexity), true

	case "ScrapedPerformer.tattoos":
		if e.complexity.ScrapedPerformer.Tattoos == nil {
			break
		}

		return e.complexity.ScrapedPerformer.Tattoos(childComplexity), true

	case "ScrapedPerformer.piercings":
		if e.complexity.ScrapedPerformer.Piercings == nil {
			break
		}

		return e.complexity.ScrapedPerformer.Piercings(childComplexity), true

	case "ScrapedPerformer.aliases":
		if e.complexity.ScrapedPerformer.Aliases == nil {
			break
		}

		return e.complexity.ScrapedPerformer.Aliases(childComplexity), true

	case "StatsResultType.scene_count":
		if e.complexity.StatsResultType.SceneCount == nil {
			break
		}

		return e.complexity.StatsResultType.SceneCount(childComplexity), true

	case "StatsResultType.gallery_count":
		if e.complexity.StatsResultType.GalleryCount == nil {
			break
		}

		return e.complexity.StatsResultType.GalleryCount(childComplexity), true

	case "StatsResultType.performer_count":
		if e.complexity.StatsResultType.PerformerCount == nil {
			break
		}

		return e.complexity.StatsResultType.PerformerCount(childComplexity), true

	case "StatsResultType.studio_count":
		if e.complexity.StatsResultType.StudioCount == nil {
			break
		}

		return e.complexity.StatsResultType.StudioCount(childComplexity), true

	case "StatsResultType.tag_count":
		if e.complexity.StatsResultType.TagCount == nil {
			break
		}

		return e.complexity.StatsResultType.TagCount(childComplexity), true

	case "Studio.id":
		if e.complexity.Studio.Id == nil {
			break
		}

		return e.complexity.Studio.Id(childComplexity), true

	case "Studio.checksum":
		if e.complexity.Studio.Checksum == nil {
			break
		}

		return e.complexity.Studio.Checksum(childComplexity), true

	case "Studio.name":
		if e.complexity.Studio.Name == nil {
			break
		}

		return e.complexity.Studio.Name(childComplexity), true

	case "Studio.url":
		if e.complexity.Studio.Url == nil {
			break
		}

		return e.complexity.Studio.Url(childComplexity), true

	case "Studio.image_path":
		if e.complexity.Studio.ImagePath == nil {
			break
		}

		return e.complexity.Studio.ImagePath(childComplexity), true

	case "Studio.scene_count":
		if e.complexity.Studio.SceneCount == nil {
			break
		}

		return e.complexity.Studio.SceneCount(childComplexity), true

	case "Subscription.metadataUpdate":
		if e.complexity.Subscription.MetadataUpdate == nil {
			break
		}

		return e.complexity.Subscription.MetadataUpdate(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.Id == nil {
			break
		}

		return e.complexity.Tag.Id(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "Tag.scene_count":
		if e.complexity.Tag.SceneCount == nil {
			break
		}

		return e.complexity.Tag.SceneCount(childComplexity), true

	case "Tag.scene_marker_count":
		if e.complexity.Tag.SceneMarkerCount == nil {
			break
		}

		return e.complexity.Tag.SceneMarkerCount(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	next := ec._Subscription(ctx, op.SelectionSet)
	if ec.Errors != nil {
		return graphql.OneShot(&graphql.Response{Data: []byte("null"), Errors: ec.Errors})
	}

	var buf bytes.Buffer
	return func() *graphql.Response {
		buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)
			return buf.Bytes()
		})

		if buf == nil {
			return nil
		}

		return &graphql.Response{
			Data:       buf,
			Errors:     ec.Errors,
			Extensions: ec.Extensions,
		}
	}
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var configGeneralResultImplementors = []string{"ConfigGeneralResult"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ConfigGeneralResult(ctx context.Context, sel ast.SelectionSet, obj *ConfigGeneralResult) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, configGeneralResultImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigGeneralResult")
		case "stashes":
			out.Values[i] = ec._ConfigGeneralResult_stashes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "databasePath":
			out.Values[i] = ec._ConfigGeneralResult_databasePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "generatedPath":
			out.Values[i] = ec._ConfigGeneralResult_generatedPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ConfigGeneralResult_stashes(ctx context.Context, field graphql.CollectedField, obj *ConfigGeneralResult) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigGeneralResult",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stashes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _ConfigGeneralResult_databasePath(ctx context.Context, field graphql.CollectedField, obj *ConfigGeneralResult) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigGeneralResult",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DatabasePath, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _ConfigGeneralResult_generatedPath(ctx context.Context, field graphql.CollectedField, obj *ConfigGeneralResult) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigGeneralResult",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GeneratedPath, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var configResultImplementors = []string{"ConfigResult"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ConfigResult(ctx context.Context, sel ast.SelectionSet, obj *ConfigResult) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, configResultImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigResult")
		case "general":
			out.Values[i] = ec._ConfigResult_general(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ConfigResult_general(ctx context.Context, field graphql.CollectedField, obj *ConfigResult) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ConfigResult",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.General, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ConfigGeneralResult)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ConfigGeneralResult(ctx, field.Selections, &res)
}

var findGalleriesResultTypeImplementors = []string{"FindGalleriesResultType"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FindGalleriesResultType(ctx context.Context, sel ast.SelectionSet, obj *FindGalleriesResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, findGalleriesResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FindGalleriesResultType")
		case "count":
			out.Values[i] = ec._FindGalleriesResultType_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "galleries":
			out.Values[i] = ec._FindGalleriesResultType_galleries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FindGalleriesResultType_count(ctx context.Context, field graphql.CollectedField, obj *FindGalleriesResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FindGalleriesResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _FindGalleriesResultType_galleries(ctx context.Context, field graphql.CollectedField, obj *FindGalleriesResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FindGalleriesResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Galleries, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Gallery)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Gallery(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var findPerformersResultTypeImplementors = []string{"FindPerformersResultType"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FindPerformersResultType(ctx context.Context, sel ast.SelectionSet, obj *FindPerformersResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, findPerformersResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FindPerformersResultType")
		case "count":
			out.Values[i] = ec._FindPerformersResultType_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "performers":
			out.Values[i] = ec._FindPerformersResultType_performers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FindPerformersResultType_count(ctx context.Context, field graphql.CollectedField, obj *FindPerformersResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FindPerformersResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _FindPerformersResultType_performers(ctx context.Context, field graphql.CollectedField, obj *FindPerformersResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FindPerformersResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Performers, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Performer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Performer(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var findSceneMarkersResultTypeImplementors = []string{"FindSceneMarkersResultType"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FindSceneMarkersResultType(ctx context.Context, sel ast.SelectionSet, obj *FindSceneMarkersResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, findSceneMarkersResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FindSceneMarkersResultType")
		case "count":
			out.Values[i] = ec._FindSceneMarkersResultType_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "scene_markers":
			out.Values[i] = ec._FindSceneMarkersResultType_scene_markers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FindSceneMarkersResultType_count(ctx context.Context, field graphql.CollectedField, obj *FindSceneMarkersResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FindSceneMarkersResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _FindSceneMarkersResultType_scene_markers(ctx context.Context, field graphql.CollectedField, obj *FindSceneMarkersResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FindSceneMarkersResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SceneMarkers, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]SceneMarker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._SceneMarker(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var findScenesResultTypeImplementors = []string{"FindScenesResultType"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FindScenesResultType(ctx context.Context, sel ast.SelectionSet, obj *FindScenesResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, findScenesResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FindScenesResultType")
		case "count":
			out.Values[i] = ec._FindScenesResultType_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "scenes":
			out.Values[i] = ec._FindScenesResultType_scenes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FindScenesResultType_count(ctx context.Context, field graphql.CollectedField, obj *FindScenesResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FindScenesResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _FindScenesResultType_scenes(ctx context.Context, field graphql.CollectedField, obj *FindScenesResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FindScenesResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scenes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Scene)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Scene(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var findStudiosResultTypeImplementors = []string{"FindStudiosResultType"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FindStudiosResultType(ctx context.Context, sel ast.SelectionSet, obj *FindStudiosResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, findStudiosResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FindStudiosResultType")
		case "count":
			out.Values[i] = ec._FindStudiosResultType_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "studios":
			out.Values[i] = ec._FindStudiosResultType_studios(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FindStudiosResultType_count(ctx context.Context, field graphql.CollectedField, obj *FindStudiosResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FindStudiosResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _FindStudiosResultType_studios(ctx context.Context, field graphql.CollectedField, obj *FindStudiosResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "FindStudiosResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Studios, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Studio)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Studio(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var galleryImplementors = []string{"Gallery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Gallery(ctx context.Context, sel ast.SelectionSet, obj *Gallery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, galleryImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Gallery")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Gallery_id(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "checksum":
			out.Values[i] = ec._Gallery_checksum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "path":
			out.Values[i] = ec._Gallery_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "title":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Gallery_title(ctx, field, obj)
				return res
			})
		case "files":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Gallery_files(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Gallery_id(ctx context.Context, field graphql.CollectedField, obj *Gallery) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Gallery",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Gallery().ID(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Gallery_checksum(ctx context.Context, field graphql.CollectedField, obj *Gallery) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Gallery",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Checksum, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Gallery_path(ctx context.Context, field graphql.CollectedField, obj *Gallery) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Gallery",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Gallery_title(ctx context.Context, field graphql.CollectedField, obj *Gallery) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Gallery",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Gallery().Title(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Gallery_files(ctx context.Context, field graphql.CollectedField, obj *Gallery) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Gallery",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Gallery().Files(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]GalleryFilesType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._GalleryFilesType(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var galleryFilesTypeImplementors = []string{"GalleryFilesType"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GalleryFilesType(ctx context.Context, sel ast.SelectionSet, obj *GalleryFilesType) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, galleryFilesTypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GalleryFilesType")
		case "index":
			out.Values[i] = ec._GalleryFilesType_index(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._GalleryFilesType_name(ctx, field, obj)
		case "path":
			out.Values[i] = ec._GalleryFilesType_path(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _GalleryFilesType_index(ctx context.Context, field graphql.CollectedField, obj *GalleryFilesType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "GalleryFilesType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _GalleryFilesType_name(ctx context.Context, field graphql.CollectedField, obj *GalleryFilesType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "GalleryFilesType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _GalleryFilesType_path(ctx context.Context, field graphql.CollectedField, obj *GalleryFilesType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "GalleryFilesType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var markerStringsResultTypeImplementors = []string{"MarkerStringsResultType"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _MarkerStringsResultType(ctx context.Context, sel ast.SelectionSet, obj *MarkerStringsResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, markerStringsResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MarkerStringsResultType")
		case "count":
			out.Values[i] = ec._MarkerStringsResultType_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "id":
			out.Values[i] = ec._MarkerStringsResultType_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "title":
			out.Values[i] = ec._MarkerStringsResultType_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _MarkerStringsResultType_count(ctx context.Context, field graphql.CollectedField, obj *MarkerStringsResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "MarkerStringsResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _MarkerStringsResultType_id(ctx context.Context, field graphql.CollectedField, obj *MarkerStringsResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "MarkerStringsResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _MarkerStringsResultType_title(ctx context.Context, field graphql.CollectedField, obj *MarkerStringsResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "MarkerStringsResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "sceneUpdate":
			out.Values[i] = ec._Mutation_sceneUpdate(ctx, field)
		case "sceneMarkerCreate":
			out.Values[i] = ec._Mutation_sceneMarkerCreate(ctx, field)
		case "sceneMarkerUpdate":
			out.Values[i] = ec._Mutation_sceneMarkerUpdate(ctx, field)
		case "sceneMarkerDestroy":
			out.Values[i] = ec._Mutation_sceneMarkerDestroy(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "performerCreate":
			out.Values[i] = ec._Mutation_performerCreate(ctx, field)
		case "performerUpdate":
			out.Values[i] = ec._Mutation_performerUpdate(ctx, field)
		case "studioCreate":
			out.Values[i] = ec._Mutation_studioCreate(ctx, field)
		case "studioUpdate":
			out.Values[i] = ec._Mutation_studioUpdate(ctx, field)
		case "tagCreate":
			out.Values[i] = ec._Mutation_tagCreate(ctx, field)
		case "tagUpdate":
			out.Values[i] = ec._Mutation_tagUpdate(ctx, field)
		case "tagDestroy":
			out.Values[i] = ec._Mutation_tagDestroy(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "configureGeneral":
			out.Values[i] = ec._Mutation_configureGeneral(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_sceneUpdate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_sceneUpdate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SceneUpdate(rctx, args["input"].(SceneUpdateInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Scene)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Scene(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_sceneMarkerCreate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_sceneMarkerCreate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SceneMarkerCreate(rctx, args["input"].(SceneMarkerCreateInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SceneMarker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._SceneMarker(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_sceneMarkerUpdate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_sceneMarkerUpdate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SceneMarkerUpdate(rctx, args["input"].(SceneMarkerUpdateInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SceneMarker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._SceneMarker(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_sceneMarkerDestroy(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_sceneMarkerDestroy_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SceneMarkerDestroy(rctx, args["id"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_performerCreate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_performerCreate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PerformerCreate(rctx, args["input"].(PerformerCreateInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Performer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Performer(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_performerUpdate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_performerUpdate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PerformerUpdate(rctx, args["input"].(PerformerUpdateInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Performer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Performer(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_studioCreate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_studioCreate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().StudioCreate(rctx, args["input"].(StudioCreateInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Studio)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Studio(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_studioUpdate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_studioUpdate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().StudioUpdate(rctx, args["input"].(StudioUpdateInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Studio)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Studio(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_tagCreate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tagCreate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TagCreate(rctx, args["input"].(TagCreateInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tag)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Tag(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_tagUpdate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tagUpdate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TagUpdate(rctx, args["input"].(TagUpdateInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tag)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Tag(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_tagDestroy(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_tagDestroy_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TagDestroy(rctx, args["input"].(TagDestroyInput))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_configureGeneral(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_configureGeneral_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfigureGeneral(rctx, args["input"].(ConfigGeneralInput))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ConfigGeneralResult)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ConfigGeneralResult(ctx, field.Selections, &res)
}

var performerImplementors = []string{"Performer"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Performer(ctx context.Context, sel ast.SelectionSet, obj *Performer) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, performerImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Performer")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_id(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "checksum":
			out.Values[i] = ec._Performer_checksum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_name(ctx, field, obj)
				return res
			})
		case "url":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_url(ctx, field, obj)
				return res
			})
		case "twitter":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_twitter(ctx, field, obj)
				return res
			})
		case "instagram":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_instagram(ctx, field, obj)
				return res
			})
		case "birthdate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_birthdate(ctx, field, obj)
				return res
			})
		case "ethnicity":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_ethnicity(ctx, field, obj)
				return res
			})
		case "country":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_country(ctx, field, obj)
				return res
			})
		case "eye_color":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_eye_color(ctx, field, obj)
				return res
			})
		case "height":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_height(ctx, field, obj)
				return res
			})
		case "measurements":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_measurements(ctx, field, obj)
				return res
			})
		case "fake_tits":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_fake_tits(ctx, field, obj)
				return res
			})
		case "career_length":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_career_length(ctx, field, obj)
				return res
			})
		case "tattoos":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_tattoos(ctx, field, obj)
				return res
			})
		case "piercings":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_piercings(ctx, field, obj)
				return res
			})
		case "aliases":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_aliases(ctx, field, obj)
				return res
			})
		case "favorite":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_favorite(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "image_path":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_image_path(ctx, field, obj)
				return res
			})
		case "scene_count":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_scene_count(ctx, field, obj)
				return res
			})
		case "scenes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Performer_scenes(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Performer_id(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().ID(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_checksum(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Checksum, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_name(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Name(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_url(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().URL(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_twitter(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Twitter(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_instagram(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Instagram(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_birthdate(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Birthdate(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_ethnicity(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Ethnicity(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_country(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Country(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_eye_color(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().EyeColor(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_height(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Height(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_measurements(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Measurements(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_fake_tits(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().FakeTits(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_career_length(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().CareerLength(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_tattoos(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Tattoos(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_piercings(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Piercings(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_aliases(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Aliases(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_favorite(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Favorite(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_image_path(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().ImagePath(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_scene_count(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().SceneCount(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Performer_scenes(ctx context.Context, field graphql.CollectedField, obj *Performer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Performer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Scenes(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Scene)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Scene(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "findScene":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_findScene(ctx, field)
				return res
			})
		case "findScenes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_findScenes(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "findSceneMarkers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_findSceneMarkers(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "findPerformer":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_findPerformer(ctx, field)
				return res
			})
		case "findPerformers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_findPerformers(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "findStudio":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_findStudio(ctx, field)
				return res
			})
		case "findStudios":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_findStudios(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "findGallery":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_findGallery(ctx, field)
				return res
			})
		case "findGalleries":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_findGalleries(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "findTag":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_findTag(ctx, field)
				return res
			})
		case "markerWall":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_markerWall(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "sceneWall":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_sceneWall(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "markerStrings":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_markerStrings(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "validGalleriesForScene":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_validGalleriesForScene(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "stats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_stats(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "sceneMarkerTags":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_sceneMarkerTags(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "scrapeFreeones":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_scrapeFreeones(ctx, field)
				return res
			})
		case "scrapeFreeonesPerformerList":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_scrapeFreeonesPerformerList(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "configuration":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_configuration(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "directories":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_directories(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "metadataImport":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_metadataImport(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "metadataExport":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_metadataExport(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "metadataScan":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_metadataScan(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "metadataGenerate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_metadataGenerate(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "metadataClean":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_metadataClean(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "allPerformers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_allPerformers(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "allStudios":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_allStudios(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "allTags":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Query_allTags(ctx, field)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Query_findScene(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findScene_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindScene(rctx, args["id"].(*string), args["checksum"].(*string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Scene)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Scene(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_findScenes(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findScenes_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindScenes(rctx, args["scene_filter"].(*SceneFilterType), args["scene_ids"].([]int), args["filter"].(*FindFilterType))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FindScenesResultType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FindScenesResultType(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_findSceneMarkers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findSceneMarkers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindSceneMarkers(rctx, args["scene_marker_filter"].(*SceneMarkerFilterType), args["filter"].(*FindFilterType))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FindSceneMarkersResultType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FindSceneMarkersResultType(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_findPerformer(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findPerformer_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindPerformer(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Performer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Performer(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_findPerformers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findPerformers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindPerformers(rctx, args["performer_filter"].(*PerformerFilterType), args["filter"].(*FindFilterType))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FindPerformersResultType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FindPerformersResultType(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_findStudio(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findStudio_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindStudio(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Studio)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Studio(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_findStudios(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findStudios_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindStudios(rctx, args["filter"].(*FindFilterType))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FindStudiosResultType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FindStudiosResultType(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_findGallery(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findGallery_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindGallery(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Gallery)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Gallery(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_findGalleries(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findGalleries_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindGalleries(rctx, args["filter"].(*FindFilterType))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FindGalleriesResultType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FindGalleriesResultType(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_findTag(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findTag_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindTag(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tag)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Tag(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_markerWall(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_markerWall_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MarkerWall(rctx, args["q"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]SceneMarker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._SceneMarker(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_sceneWall(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_sceneWall_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SceneWall(rctx, args["q"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Scene)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Scene(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_markerStrings(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_markerStrings_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MarkerStrings(rctx, args["q"].(*string), args["sort"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*MarkerStringsResultType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._MarkerStringsResultType(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_validGalleriesForScene(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_validGalleriesForScene_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ValidGalleriesForScene(rctx, args["scene_id"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Gallery)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Gallery(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_stats(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Stats(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(StatsResultType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._StatsResultType(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_sceneMarkerTags(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_sceneMarkerTags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SceneMarkerTags(rctx, args["scene_id"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]SceneMarkerTag)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._SceneMarkerTag(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_scrapeFreeones(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_scrapeFreeones_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ScrapeFreeones(rctx, args["performer_name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ScrapedPerformer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._ScrapedPerformer(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_scrapeFreeonesPerformerList(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_scrapeFreeonesPerformerList_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ScrapeFreeonesPerformerList(rctx, args["query"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_configuration(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Configuration(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ConfigResult)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ConfigResult(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_directories(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_directories_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Directories(rctx, args["path"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_metadataImport(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MetadataImport(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_metadataExport(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MetadataExport(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_metadataScan(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MetadataScan(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_metadataGenerate(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_metadataGenerate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MetadataGenerate(rctx, args["input"].(GenerateMetadataInput))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_metadataClean(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MetadataClean(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_allPerformers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllPerformers(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Performer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Performer(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_allStudios(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllStudios(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Studio)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Studio(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_allTags(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllTags(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Tag)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Tag(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Schema(ctx, field.Selections, res)
}

var sceneImplementors = []string{"Scene"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Scene(ctx context.Context, sel ast.SelectionSet, obj *Scene) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, sceneImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Scene")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_id(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "checksum":
			out.Values[i] = ec._Scene_checksum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "title":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_title(ctx, field, obj)
				return res
			})
		case "details":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_details(ctx, field, obj)
				return res
			})
		case "url":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_url(ctx, field, obj)
				return res
			})
		case "date":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_date(ctx, field, obj)
				return res
			})
		case "rating":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_rating(ctx, field, obj)
				return res
			})
		case "path":
			out.Values[i] = ec._Scene_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "file":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_file(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "paths":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_paths(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "is_streamable":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_is_streamable(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "scene_markers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_scene_markers(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "gallery":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_gallery(ctx, field, obj)
				return res
			})
		case "studio":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_studio(ctx, field, obj)
				return res
			})
		case "tags":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_tags(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "performers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Scene_performers(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Scene_id(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().ID(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_checksum(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Checksum, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_title(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Title(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_details(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Details(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_url(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().URL(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_date(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Date(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_rating(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Rating(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_path(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_file(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().File(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SceneFileType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._SceneFileType(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_paths(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Paths(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ScenePathsType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ScenePathsType(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_is_streamable(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().IsStreamable(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_scene_markers(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().SceneMarkers(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]SceneMarker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._SceneMarker(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Scene_gallery(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Gallery(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Gallery)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Gallery(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_studio(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Studio(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Studio)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Studio(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Scene_tags(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Tags(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Tag)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Tag(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Scene_performers(ctx context.Context, field graphql.CollectedField, obj *Scene) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Scene",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Performers(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Performer)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Performer(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var sceneFileTypeImplementors = []string{"SceneFileType"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SceneFileType(ctx context.Context, sel ast.SelectionSet, obj *SceneFileType) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, sceneFileTypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SceneFileType")
		case "size":
			out.Values[i] = ec._SceneFileType_size(ctx, field, obj)
		case "duration":
			out.Values[i] = ec._SceneFileType_duration(ctx, field, obj)
		case "video_codec":
			out.Values[i] = ec._SceneFileType_video_codec(ctx, field, obj)
		case "audio_codec":
			out.Values[i] = ec._SceneFileType_audio_codec(ctx, field, obj)
		case "width":
			out.Values[i] = ec._SceneFileType_width(ctx, field, obj)
		case "height":
			out.Values[i] = ec._SceneFileType_height(ctx, field, obj)
		case "framerate":
			out.Values[i] = ec._SceneFileType_framerate(ctx, field, obj)
		case "bitrate":
			out.Values[i] = ec._SceneFileType_bitrate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SceneFileType_size(ctx context.Context, field graphql.CollectedField, obj *SceneFileType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneFileType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneFileType_duration(ctx context.Context, field graphql.CollectedField, obj *SceneFileType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneFileType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalFloat(*res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneFileType_video_codec(ctx context.Context, field graphql.CollectedField, obj *SceneFileType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneFileType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VideoCodec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneFileType_audio_codec(ctx context.Context, field graphql.CollectedField, obj *SceneFileType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneFileType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AudioCodec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneFileType_width(ctx context.Context, field graphql.CollectedField, obj *SceneFileType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneFileType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Width, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneFileType_height(ctx context.Context, field graphql.CollectedField, obj *SceneFileType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneFileType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneFileType_framerate(ctx context.Context, field graphql.CollectedField, obj *SceneFileType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneFileType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Framerate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalFloat(*res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneFileType_bitrate(ctx context.Context, field graphql.CollectedField, obj *SceneFileType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneFileType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bitrate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

var sceneMarkerImplementors = []string{"SceneMarker"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SceneMarker(ctx context.Context, sel ast.SelectionSet, obj *SceneMarker) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, sceneMarkerImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SceneMarker")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._SceneMarker_id(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "scene":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._SceneMarker_scene(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "title":
			out.Values[i] = ec._SceneMarker_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "seconds":
			out.Values[i] = ec._SceneMarker_seconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "primary_tag":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._SceneMarker_primary_tag(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "tags":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._SceneMarker_tags(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "stream":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._SceneMarker_stream(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "preview":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._SceneMarker_preview(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SceneMarker_id(ctx context.Context, field graphql.CollectedField, obj *SceneMarker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneMarker",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneMarker().ID(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneMarker_scene(ctx context.Context, field graphql.CollectedField, obj *SceneMarker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneMarker",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneMarker().Scene(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Scene)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Scene(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneMarker_title(ctx context.Context, field graphql.CollectedField, obj *SceneMarker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneMarker",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneMarker_seconds(ctx context.Context, field graphql.CollectedField, obj *SceneMarker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneMarker",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Seconds, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalFloat(res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneMarker_primary_tag(ctx context.Context, field graphql.CollectedField, obj *SceneMarker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneMarker",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneMarker().PrimaryTag(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Tag)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Tag(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneMarker_tags(ctx context.Context, field graphql.CollectedField, obj *SceneMarker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneMarker",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneMarker().Tags(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Tag)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Tag(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _SceneMarker_stream(ctx context.Context, field graphql.CollectedField, obj *SceneMarker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneMarker",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneMarker().Stream(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneMarker_preview(ctx context.Context, field graphql.CollectedField, obj *SceneMarker) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneMarker",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneMarker().Preview(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var sceneMarkerTagImplementors = []string{"SceneMarkerTag"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SceneMarkerTag(ctx context.Context, sel ast.SelectionSet, obj *SceneMarkerTag) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, sceneMarkerTagImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SceneMarkerTag")
		case "tag":
			out.Values[i] = ec._SceneMarkerTag_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "scene_markers":
			out.Values[i] = ec._SceneMarkerTag_scene_markers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SceneMarkerTag_tag(ctx context.Context, field graphql.CollectedField, obj *SceneMarkerTag) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneMarkerTag",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Tag)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Tag(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _SceneMarkerTag_scene_markers(ctx context.Context, field graphql.CollectedField, obj *SceneMarkerTag) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SceneMarkerTag",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SceneMarkers, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]SceneMarker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._SceneMarker(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var scenePathsTypeImplementors = []string{"ScenePathsType"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ScenePathsType(ctx context.Context, sel ast.SelectionSet, obj *ScenePathsType) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, scenePathsTypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ScenePathsType")
		case "screenshot":
			out.Values[i] = ec._ScenePathsType_screenshot(ctx, field, obj)
		case "preview":
			out.Values[i] = ec._ScenePathsType_preview(ctx, field, obj)
		case "stream":
			out.Values[i] = ec._ScenePathsType_stream(ctx, field, obj)
		case "webp":
			out.Values[i] = ec._ScenePathsType_webp(ctx, field, obj)
		case "vtt":
			out.Values[i] = ec._ScenePathsType_vtt(ctx, field, obj)
		case "chapters_vtt":
			out.Values[i] = ec._ScenePathsType_chapters_vtt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ScenePathsType_screenshot(ctx context.Context, field graphql.CollectedField, obj *ScenePathsType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScenePathsType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Screenshot, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScenePathsType_preview(ctx context.Context, field graphql.CollectedField, obj *ScenePathsType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScenePathsType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Preview, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScenePathsType_stream(ctx context.Context, field graphql.CollectedField, obj *ScenePathsType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScenePathsType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stream, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScenePathsType_webp(ctx context.Context, field graphql.CollectedField, obj *ScenePathsType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScenePathsType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Webp, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScenePathsType_vtt(ctx context.Context, field graphql.CollectedField, obj *ScenePathsType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScenePathsType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vtt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScenePathsType_chapters_vtt(ctx context.Context, field graphql.CollectedField, obj *ScenePathsType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScenePathsType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaptersVtt, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var scrapedPerformerImplementors = []string{"ScrapedPerformer"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ScrapedPerformer(ctx context.Context, sel ast.SelectionSet, obj *ScrapedPerformer) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, scrapedPerformerImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ScrapedPerformer")
		case "name":
			out.Values[i] = ec._ScrapedPerformer_name(ctx, field, obj)
		case "url":
			out.Values[i] = ec._ScrapedPerformer_url(ctx, field, obj)
		case "twitter":
			out.Values[i] = ec._ScrapedPerformer_twitter(ctx, field, obj)
		case "instagram":
			out.Values[i] = ec._ScrapedPerformer_instagram(ctx, field, obj)
		case "birthdate":
			out.Values[i] = ec._ScrapedPerformer_birthdate(ctx, field, obj)
		case "ethnicity":
			out.Values[i] = ec._ScrapedPerformer_ethnicity(ctx, field, obj)
		case "country":
			out.Values[i] = ec._ScrapedPerformer_country(ctx, field, obj)
		case "eye_color":
			out.Values[i] = ec._ScrapedPerformer_eye_color(ctx, field, obj)
		case "height":
			out.Values[i] = ec._ScrapedPerformer_height(ctx, field, obj)
		case "measurements":
			out.Values[i] = ec._ScrapedPerformer_measurements(ctx, field, obj)
		case "fake_tits":
			out.Values[i] = ec._ScrapedPerformer_fake_tits(ctx, field, obj)
		case "career_length":
			out.Values[i] = ec._ScrapedPerformer_career_length(ctx, field, obj)
		case "tattoos":
			out.Values[i] = ec._ScrapedPerformer_tattoos(ctx, field, obj)
		case "piercings":
			out.Values[i] = ec._ScrapedPerformer_piercings(ctx, field, obj)
		case "aliases":
			out.Values[i] = ec._ScrapedPerformer_aliases(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_name(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_url(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_twitter(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Twitter, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_instagram(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Instagram, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_birthdate(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Birthdate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_ethnicity(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ethnicity, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_country(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Country, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_eye_color(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EyeColor, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_height(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_measurements(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Measurements, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_fake_tits(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FakeTits, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_career_length(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CareerLength, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_tattoos(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tattoos, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_piercings(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Piercings, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ScrapedPerformer_aliases(ctx context.Context, field graphql.CollectedField, obj *ScrapedPerformer) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ScrapedPerformer",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aliases, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var statsResultTypeImplementors = []string{"StatsResultType"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StatsResultType(ctx context.Context, sel ast.SelectionSet, obj *StatsResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statsResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatsResultType")
		case "scene_count":
			out.Values[i] = ec._StatsResultType_scene_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "gallery_count":
			out.Values[i] = ec._StatsResultType_gallery_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "performer_count":
			out.Values[i] = ec._StatsResultType_performer_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "studio_count":
			out.Values[i] = ec._StatsResultType_studio_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "tag_count":
			out.Values[i] = ec._StatsResultType_tag_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _StatsResultType_scene_count(ctx context.Context, field graphql.CollectedField, obj *StatsResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SceneCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsResultType_gallery_count(ctx context.Context, field graphql.CollectedField, obj *StatsResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GalleryCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsResultType_performer_count(ctx context.Context, field graphql.CollectedField, obj *StatsResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerformerCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsResultType_studio_count(ctx context.Context, field graphql.CollectedField, obj *StatsResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StudioCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsResultType_tag_count(ctx context.Context, field graphql.CollectedField, obj *StatsResultType) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsResultType",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TagCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var studioImplementors = []string{"Studio"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Studio(ctx context.Context, sel ast.SelectionSet, obj *Studio) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, studioImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Studio")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Studio_id(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "checksum":
			out.Values[i] = ec._Studio_checksum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Studio_name(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "url":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Studio_url(ctx, field, obj)
				return res
			})
		case "image_path":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Studio_image_path(ctx, field, obj)
				return res
			})
		case "scene_count":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Studio_scene_count(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Studio_id(ctx context.Context, field graphql.CollectedField, obj *Studio) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Studio",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().ID(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Studio_checksum(ctx context.Context, field graphql.CollectedField, obj *Studio) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Studio",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Checksum, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Studio_name(ctx context.Context, field graphql.CollectedField, obj *Studio) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Studio",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().Name(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Studio_url(ctx context.Context, field graphql.CollectedField, obj *Studio) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Studio",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().URL(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Studio_image_path(ctx context.Context, field graphql.CollectedField, obj *Studio) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Studio",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().ImagePath(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Studio_scene_count(ctx context.Context, field graphql.CollectedField, obj *Studio) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Studio",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().SceneCount(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

var subscriptionImplementors = []string{"Subscription"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, subscriptionImplementors)
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "metadataUpdate":
		return ec._Subscription_metadataUpdate(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

func (ec *executionContext) _Subscription_metadataUpdate(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
		Args:  nil,
	})
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().MetadataUpdate(rctx)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			func() graphql.Marshaler {
				return graphql.MarshalString(res)
			}().MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

var tagImplementors = []string{"Tag"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tagImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Tag_id(ctx, field, obj)
				if res == graphql.Null {
					invalid = true
				}
				return res
			})
		case "name":
			out.Values[i] = ec._Tag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "scene_count":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Tag_scene_count(ctx, field, obj)
				return res
			})
		case "scene_marker_count":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				res = ec._Tag_scene_marker_count(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Tag_id(ctx context.Context, field graphql.CollectedField, obj *Tag) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Tag",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().ID(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Tag_name(ctx context.Context, field graphql.CollectedField, obj *Tag) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Tag",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Tag_scene_count(ctx context.Context, field graphql.CollectedField, obj *Tag) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Tag",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().SceneCount(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Tag_scene_marker_count(ctx context.Context, field graphql.CollectedField, obj *Tag) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Tag",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().SceneMarkerCount(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Directive(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Field(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___EnumValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Field:  field,
		Args:   nil,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

func UnmarshalConfigGeneralInput(v interface{}) (ConfigGeneralInput, error) {
	var it ConfigGeneralInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "stashes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Stashes = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Stashes[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "databasePath":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.DatabasePath = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "generatedPath":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.GeneratedPath = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) ConfigGeneralInputMiddleware(ctx context.Context, obj *ConfigGeneralInput) (*ConfigGeneralInput, error) {

	return obj, nil
}

func UnmarshalFindFilterType(v interface{}) (FindFilterType, error) {
	var it FindFilterType
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "q":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Q = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "page":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.Page = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "per_page":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.PerPage = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Sort = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "direction":
			var err error
			var ptr1 SortDirectionEnum
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Direction = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) FindFilterTypeMiddleware(ctx context.Context, obj *FindFilterType) (*FindFilterType, error) {

	return obj, nil
}

func UnmarshalGenerateMetadataInput(v interface{}) (GenerateMetadataInput, error) {
	var it GenerateMetadataInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "sprites":
			var err error
			it.Sprites, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		case "previews":
			var err error
			it.Previews, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		case "markers":
			var err error
			it.Markers, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		case "transcodes":
			var err error
			it.Transcodes, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) GenerateMetadataInputMiddleware(ctx context.Context, obj *GenerateMetadataInput) (*GenerateMetadataInput, error) {

	return obj, nil
}

func UnmarshalIntCriterionInput(v interface{}) (IntCriterionInput, error) {
	var it IntCriterionInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "value":
			var err error
			it.Value, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		case "modifier":
			var err error
			err = (&it.Modifier).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) IntCriterionInputMiddleware(ctx context.Context, obj *IntCriterionInput) (*IntCriterionInput, error) {

	return obj, nil
}

func UnmarshalPerformerCreateInput(v interface{}) (PerformerCreateInput, error) {
	var it PerformerCreateInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Name = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "url":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.URL = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "birthdate":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Birthdate = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "ethnicity":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Ethnicity = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "country":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Country = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "eye_color":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.EyeColor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "height":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Height = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "measurements":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Measurements = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "fake_tits":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.FakeTits = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "career_length":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.CareerLength = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "tattoos":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Tattoos = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "piercings":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Piercings = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "aliases":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Aliases = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "twitter":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Twitter = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "instagram":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Instagram = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "favorite":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.Favorite = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "image":
			var err error
			it.Image, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) PerformerCreateInputMiddleware(ctx context.Context, obj *PerformerCreateInput) (*PerformerCreateInput, error) {

	return obj, nil
}

func UnmarshalPerformerFilterType(v interface{}) (PerformerFilterType, error) {
	var it PerformerFilterType
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "filter_favorites":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.FilterFavorites = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) PerformerFilterTypeMiddleware(ctx context.Context, obj *PerformerFilterType) (*PerformerFilterType, error) {

	return obj, nil
}

func UnmarshalPerformerUpdateInput(v interface{}) (PerformerUpdateInput, error) {
	var it PerformerUpdateInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Name = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "url":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.URL = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "birthdate":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Birthdate = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "ethnicity":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Ethnicity = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "country":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Country = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "eye_color":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.EyeColor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "height":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Height = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "measurements":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Measurements = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "fake_tits":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.FakeTits = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "career_length":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.CareerLength = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "tattoos":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Tattoos = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "piercings":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Piercings = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "aliases":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Aliases = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "twitter":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Twitter = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "instagram":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Instagram = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "favorite":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.Favorite = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "image":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Image = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) PerformerUpdateInputMiddleware(ctx context.Context, obj *PerformerUpdateInput) (*PerformerUpdateInput, error) {

	return obj, nil
}

func UnmarshalSceneFilterType(v interface{}) (SceneFilterType, error) {
	var it SceneFilterType
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "rating":
			var err error
			var ptr1 IntCriterionInput
			if v != nil {
				ptr1, err = UnmarshalIntCriterionInput(v)
				it.Rating = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "resolution":
			var err error
			var ptr1 ResolutionEnum
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Resolution = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "has_markers":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.HasMarkers = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "is_missing":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.IsMissing = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "studio_id":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.StudioID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Tags = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Tags[idx1], err = graphql.UnmarshalID(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "performer_id":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.PerformerID = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) SceneFilterTypeMiddleware(ctx context.Context, obj *SceneFilterType) (*SceneFilterType, error) {

	if obj.Rating != nil {
		var err error
		obj.Rating, err = e.IntCriterionInputMiddleware(ctx, obj.Rating)
		if err != nil {
			return nil, err
		}
	}

	return obj, nil
}

func UnmarshalSceneMarkerCreateInput(v interface{}) (SceneMarkerCreateInput, error) {
	var it SceneMarkerCreateInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "title":
			var err error
			it.Title, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "seconds":
			var err error
			it.Seconds, err = graphql.UnmarshalFloat(v)
			if err != nil {
				return it, err
			}
		case "scene_id":
			var err error
			it.SceneID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "primary_tag_id":
			var err error
			it.PrimaryTagID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "tag_ids":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.TagIds = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.TagIds[idx1], err = graphql.UnmarshalID(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) SceneMarkerCreateInputMiddleware(ctx context.Context, obj *SceneMarkerCreateInput) (*SceneMarkerCreateInput, error) {

	return obj, nil
}

func UnmarshalSceneMarkerFilterType(v interface{}) (SceneMarkerFilterType, error) {
	var it SceneMarkerFilterType
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "tag_id":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.TagID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "tags":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Tags = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Tags[idx1], err = graphql.UnmarshalID(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "scene_tags":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.SceneTags = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.SceneTags[idx1], err = graphql.UnmarshalID(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "performers":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Performers = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Performers[idx1], err = graphql.UnmarshalID(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) SceneMarkerFilterTypeMiddleware(ctx context.Context, obj *SceneMarkerFilterType) (*SceneMarkerFilterType, error) {

	return obj, nil
}

func UnmarshalSceneMarkerUpdateInput(v interface{}) (SceneMarkerUpdateInput, error) {
	var it SceneMarkerUpdateInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "title":
			var err error
			it.Title, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "seconds":
			var err error
			it.Seconds, err = graphql.UnmarshalFloat(v)
			if err != nil {
				return it, err
			}
		case "scene_id":
			var err error
			it.SceneID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "primary_tag_id":
			var err error
			it.PrimaryTagID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "tag_ids":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.TagIds = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.TagIds[idx1], err = graphql.UnmarshalID(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) SceneMarkerUpdateInputMiddleware(ctx context.Context, obj *SceneMarkerUpdateInput) (*SceneMarkerUpdateInput, error) {

	return obj, nil
}

func UnmarshalSceneUpdateInput(v interface{}) (SceneUpdateInput, error) {
	var it SceneUpdateInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clientMutationId":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ClientMutationID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "id":
			var err error
			it.ID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "title":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Title = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "details":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Details = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "url":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.URL = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "date":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Date = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "rating":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.Rating = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "studio_id":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.StudioID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "gallery_id":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.GalleryID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "performer_ids":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.PerformerIds = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.PerformerIds[idx1], err = graphql.UnmarshalID(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "tag_ids":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.TagIds = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.TagIds[idx1], err = graphql.UnmarshalID(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) SceneUpdateInputMiddleware(ctx context.Context, obj *SceneUpdateInput) (*SceneUpdateInput, error) {

	return obj, nil
}

func UnmarshalStudioCreateInput(v interface{}) (StudioCreateInput, error) {
	var it StudioCreateInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "url":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.URL = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "image":
			var err error
			it.Image, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) StudioCreateInputMiddleware(ctx context.Context, obj *StudioCreateInput) (*StudioCreateInput, error) {

	return obj, nil
}

func UnmarshalStudioUpdateInput(v interface{}) (StudioUpdateInput, error) {
	var it StudioUpdateInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Name = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "url":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.URL = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "image":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Image = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) StudioUpdateInputMiddleware(ctx context.Context, obj *StudioUpdateInput) (*StudioUpdateInput, error) {

	return obj, nil
}

func UnmarshalTagCreateInput(v interface{}) (TagCreateInput, error) {
	var it TagCreateInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) TagCreateInputMiddleware(ctx context.Context, obj *TagCreateInput) (*TagCreateInput, error) {

	return obj, nil
}

func UnmarshalTagDestroyInput(v interface{}) (TagDestroyInput, error) {
	var it TagDestroyInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) TagDestroyInputMiddleware(ctx context.Context, obj *TagDestroyInput) (*TagDestroyInput, error) {

	return obj, nil
}

func UnmarshalTagUpdateInput(v interface{}) (TagUpdateInput, error) {
	var it TagUpdateInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) TagUpdateInputMiddleware(ctx context.Context, obj *TagUpdateInput) (*TagUpdateInput, error) {

	return obj, nil
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema/schema.graphql", Input: `#######################################
# Gallery
#######################################

"""Gallery type"""
type Gallery {
  id: ID!
  checksum: String!
  path: String!
  title: String

  """The files in the gallery"""
  files: [GalleryFilesType!]! # Resolver
}

type GalleryFilesType {
  index: Int!
  name: String
  path: String
}

type FindGalleriesResultType {
  count: Int!
  galleries: [Gallery!]!
}

#######################################
# Performer
#######################################

type Performer {
  id: ID!
  checksum: String!
  name: String
  url: String
  twitter: String
  instagram: String
  birthdate: String
  ethnicity: String
  country: String
  eye_color: String
  height: String
  measurements: String
  fake_tits: String
  career_length: String
  tattoos: String
  piercings: String
  aliases: String
  favorite: Boolean!

  image_path: String # Resolver
  scene_count: Int # Resolver
  scenes: [Scene!]!
}

input PerformerCreateInput {
  name: String
  url: String
  birthdate: String
  ethnicity: String
  country: String
  eye_color: String
  height: String
  measurements: String
  fake_tits: String
  career_length: String
  tattoos: String
  piercings: String
  aliases: String
  twitter: String
  instagram: String
  favorite: Boolean
  """This should be base64 encoded"""
  image: String!
}

input PerformerUpdateInput {
  id: ID!
  name: String
  url: String
  birthdate: String
  ethnicity: String
  country: String
  eye_color: String
  height: String
  measurements: String
  fake_tits: String
  career_length: String
  tattoos: String
  piercings: String
  aliases: String
  twitter: String
  instagram: String
  favorite: Boolean
  """This should be base64 encoded"""
  image: String
}

type FindPerformersResultType {
  count: Int!
  performers: [Performer!]!
}

#######################################
# Scene Marker Tag
#######################################

type SceneMarkerTag {
  tag: Tag!
  scene_markers: [SceneMarker!]!
}

#######################################
# Scene Marker
#######################################

type SceneMarker {
  id: ID!
  scene: Scene!
  title: String!
  seconds: Float!
  primary_tag: Tag!
  tags: [Tag!]!

  """The path to stream this marker"""
  stream: String! # Resolver
  """The path to the preview image for this marker"""
  preview: String! # Resolver
}

input SceneMarkerCreateInput {
  title: String!
  seconds: Float!
  scene_id: ID!
  primary_tag_id: ID!
  tag_ids: [ID!]
}

input SceneMarkerUpdateInput {
  id: ID!
  title: String!
  seconds: Float!
  scene_id: ID!
  primary_tag_id: ID!
  tag_ids: [ID!]
}

type FindSceneMarkersResultType {
  count: Int!
  scene_markers: [SceneMarker!]!
}

type MarkerStringsResultType {
  count: Int!
  id: ID!
  title: String!
}

#######################################
# Scene
#######################################

type SceneFileType {
  size: String
  duration: Float
  video_codec: String
  audio_codec: String
  width: Int
  height: Int
  framerate: Float
  bitrate: Int
}

type ScenePathsType {
  screenshot: String # Resolver
  preview: String # Resolver
  stream: String # Resolver
  webp: String # Resolver
  vtt: String # Resolver
  chapters_vtt: String # Resolver
}

type Scene {
  id: ID!
  checksum: String!
  title: String
  details: String
  url: String
  date: String
  rating: Int
  path: String!

  file: SceneFileType! # Resolver
  paths: ScenePathsType! # Resolver
  is_streamable: Boolean! # Resolver

  scene_markers: [SceneMarker!]!
  gallery: Gallery
  studio: Studio
  tags: [Tag!]!
  performers: [Performer!]!
}

input SceneUpdateInput {
  clientMutationId: String
  id: ID!
  title: String
  details: String
  url: String
  date: String
  rating: Int
  studio_id: ID
  gallery_id: ID
  performer_ids: [ID!]
  tag_ids: [ID!]
}

type FindScenesResultType {
  count: Int!
  scenes: [Scene!]!
}

#######################################
# Scraped Performer
#######################################

"""A performer from a scraping operation..."""
type ScrapedPerformer {
  name: String
  url: String
  twitter: String
  instagram: String
  birthdate: String
  ethnicity: String
  country: String
  eye_color: String
  height: String
  measurements: String
  fake_tits: String
  career_length: String
  tattoos: String
  piercings: String
  aliases: String
}

#######################################
# Stats
#######################################

type StatsResultType {
  scene_count: Int!
  gallery_count: Int!
  performer_count: Int!
  studio_count: Int!
  tag_count: Int!
}

#######################################
# Studio
#######################################

type Studio {
  id: ID!
  checksum: String!
  name: String!
  url: String

  image_path: String # Resolver
  scene_count: Int # Resolver
}

input StudioCreateInput {
  name: String!
  url: String
  """This should be base64 encoded"""
  image: String!
}

input StudioUpdateInput {
  id: ID!
  name: String
  url: String
  """This should be base64 encoded"""
  image: String
}

type FindStudiosResultType {
  count: Int!
  studios: [Studio!]!
}

#######################################
# Tag
#######################################

type Tag {
  id: ID!
  name: String!

  scene_count: Int # Resolver
  scene_marker_count: Int # Resolver
}

input TagCreateInput {
  name: String!
}

input TagUpdateInput {
  id: ID!
  name: String!
}

input TagDestroyInput {
  id: ID!
}

#######################################
# Filters
#######################################

enum SortDirectionEnum {
  ASC
  DESC
}

input FindFilterType {
  q: String
  page: Int
  per_page: Int
  sort: String
  direction: SortDirectionEnum
}

enum ResolutionEnum {
  "240p", LOW
  "480p", STANDARD
  "720p", STANDARD_HD
  "1080p", FULL_HD
  "4k", FOUR_K
}

input PerformerFilterType {
  """Filter by favorite"""
  filter_favorites: Boolean
}

input SceneMarkerFilterType {
  """Filter to only include scene markers with this tag"""
  tag_id: ID
  """Filter to only include scene markers with these tags"""
  tags: [ID!]
  """Filter to only include scene markers attached to a scene with these tags"""
  scene_tags: [ID!]
  """Filter to only include scene markers with these performers"""
  performers: [ID!]
}

input SceneFilterType {
  """Filter by rating"""
  rating: IntCriterionInput
  """Filter by resolution"""
  resolution: ResolutionEnum
  """Filter to only include scenes which have markers. ` + "`" + `true` + "`" + ` or ` + "`" + `false` + "`" + `"""
  has_markers: String
  """Filter to only include scenes missing this property"""
  is_missing: String
  """Filter to only include scenes with this studio"""
  studio_id: ID
  """Filter to only include scenes with these tags"""
  tags: [ID!]
  """Filter to only include scenes with this performer"""
  performer_id: ID
}

enum CriterionModifier {
  """="""
  EQUALS,
  """!="""
  NOT_EQUALS,
  """>"""
  GREATER_THAN,
  """<"""
  LESS_THAN,
  """IS NULL"""
  IS_NULL,
  """IS NOT NULL"""
  NOT_NULL,
  INCLUDES,
  EXCLUDES,
}

input IntCriterionInput {
  value: Int!
  modifier: CriterionModifier!
}

#######################################
# Config
#######################################

input ConfigGeneralInput {
  """Array of file paths to content"""
  stashes: [String!]
  """Path to the SQLite database"""
  databasePath: String
  """Path to generated files"""
  generatedPath: String
}

type ConfigGeneralResult {
  """Array of file paths to content"""
  stashes: [String!]!
  """Path to the SQLite database"""
  databasePath: String!
  """Path to generated files"""
  generatedPath: String!
}

"""All configuration settings"""
type ConfigResult {
  general: ConfigGeneralResult!
}

#######################################
# Metadata
#######################################

input GenerateMetadataInput {
  sprites: Boolean!
  previews: Boolean!
  markers: Boolean!
  transcodes: Boolean!
}

#############
# Root Schema
#############

"""The query root for this schema"""
type Query {
  """Find a scene by ID or Checksum"""
  findScene(id: ID, checksum: String): Scene
  """A function which queries Scene objects"""
  findScenes(scene_filter: SceneFilterType, scene_ids: [Int!], filter: FindFilterType): FindScenesResultType!

  """A function which queries SceneMarker objects"""
  findSceneMarkers(scene_marker_filter: SceneMarkerFilterType filter: FindFilterType): FindSceneMarkersResultType!

  """Find a performer by ID"""
  findPerformer(id: ID!): Performer
  """A function which queries Performer objects"""
  findPerformers(performer_filter: PerformerFilterType, filter: FindFilterType): FindPerformersResultType!

  """Find a studio by ID"""
  findStudio(id: ID!): Studio
  """A function which queries Studio objects"""
  findStudios(filter: FindFilterType): FindStudiosResultType!

  findGallery(id: ID!): Gallery
  findGalleries(filter: FindFilterType): FindGalleriesResultType!

  findTag(id: ID!): Tag

  """Retrieve random scene markers for the wall"""
  markerWall(q: String): [SceneMarker!]!
  """Retrieve random scenes for the wall"""
  sceneWall(q: String): [Scene!]!

  """Get marker strings"""
  markerStrings(q: String, sort: String): [MarkerStringsResultType]!
  """Get the list of valid galleries for a given scene ID"""
  validGalleriesForScene(scene_id: ID): [Gallery!]!
  """Get stats"""
  stats: StatsResultType!
  """Organize scene markers by tag for a given scene ID"""
  sceneMarkerTags(scene_id: ID!): [SceneMarkerTag!]!

  # Scrapers

  """Scrape a performer using Freeones"""
  scrapeFreeones(performer_name: String!): ScrapedPerformer
  """Scrape a list of performers from a query"""
  scrapeFreeonesPerformerList(query: String!): [String!]!

  # Config
  """Returns the current, complete configuration"""
  configuration: ConfigResult!
  """Returns an array of paths for the given path"""
  directories(path: String): [String!]!

  # Metadata

  """Start an import. Returns the job ID"""
  metadataImport: String!
  """Start an export. Returns the job ID"""
  metadataExport: String!
  """Start a scan. Returns the job ID"""
  metadataScan: String!
  """Start generating content. Returns the job ID"""
  metadataGenerate(input: GenerateMetadataInput!): String!
  """Clean metadata. Returns the job ID"""
  metadataClean: String!

  # Get everything

  allPerformers: [Performer!]!
  allStudios: [Studio!]!
  allTags: [Tag!]!
}

type Mutation {
  sceneUpdate(input: SceneUpdateInput!): Scene

  sceneMarkerCreate(input: SceneMarkerCreateInput!): SceneMarker
  sceneMarkerUpdate(input: SceneMarkerUpdateInput!): SceneMarker
  sceneMarkerDestroy(id: ID!): Boolean!

  performerCreate(input: PerformerCreateInput!): Performer
  performerUpdate(input: PerformerUpdateInput!): Performer

  studioCreate(input: StudioCreateInput!): Studio
  studioUpdate(input: StudioUpdateInput!): Studio

  tagCreate(input: TagCreateInput!): Tag
  tagUpdate(input: TagUpdateInput!): Tag
  tagDestroy(input: TagDestroyInput!): Boolean!

  """Change general configuration options"""
  configureGeneral(input: ConfigGeneralInput!): ConfigGeneralResult!
}

type Subscription {
  """Update from the metadata manager"""
  metadataUpdate: String!
}

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}`},
)

// ChainFieldMiddleware add chain by FieldMiddleware
// nolint: deadcode
func chainFieldMiddleware(handleFunc ...graphql.FieldMiddleware) graphql.FieldMiddleware {
	n := len(handleFunc)

	if n > 1 {
		lastI := n - 1
		return func(ctx context.Context, next graphql.Resolver) (interface{}, error) {
			var (
				chainHandler graphql.Resolver
				curI         int
			)
			chainHandler = func(currentCtx context.Context) (interface{}, error) {
				if curI == lastI {
					return next(currentCtx)
				}
				curI++
				res, err := handleFunc[curI](currentCtx, chainHandler)
				curI--
				return res, err

			}
			return handleFunc[0](ctx, chainHandler)
		}
	}

	if n == 1 {
		return handleFunc[0]
	}

	return func(ctx context.Context, next graphql.Resolver) (interface{}, error) {
		return next(ctx)
	}
}
